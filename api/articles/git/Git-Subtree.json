{"title":"Git Subtree","uid":"de1c13a150c1ef1c4839df0e0e3869a8","slug":"git/Git-Subtree","date":"2020-04-27T19:17:06.000Z","updated":"2024-11-16T08:01:11.348Z","comments":true,"path":"api/articles/git/Git-Subtree.json","keywords":null,"cover":null,"content":"<h2 id=\"用-Git-Subtree-在多个-Git-项目间双向同步子项目，附简明使用手册\"><a href=\"#用-Git-Subtree-在多个-Git-项目间双向同步子项目，附简明使用手册\" class=\"headerlink\" title=\"用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册\"></a>用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册</h2><p>转自<a href=\"https://tech.youzan.com/git-subtree/\">https://tech.youzan.com/git-subtree/</a></p>\n<blockquote>\n<p>什么时候需要 Subtree ？<br>1、当多个项目共用同一坨代码，而这坨代码跟着项目在快速更新的时候<br>2、把一部分代码迁移出去独立为一个新的 git 仓库，但又希望能够保留这部分代码的历史提交记录。</p>\n</blockquote>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>有赞微商城曾经是一个很大的前后端代码都包含在里面的 Git 项目，为了方便管理我们把前后端代码分离成 2 个 Git 仓库，进而再作分项目拆分成多个 Git 仓库。</p>\n<p>于是，就需要有好的方式同步各个项目共用的 Css 库、JS 库、PHP 库（他们都是以独立的 Git 仓库的形式存在）。而且由于开发节奏极快，我们需要这些库是<strong>可以在不同项目间双向同步的而不是单向同步</strong>。<strong>而且，最好能做到被迁移的这部分代码在新的 git 仓库里保留原有的历史提交记录。</strong></p>\n<p>举个栗子：A 项目需要在给某个子项目 W 里添加一个文件，最方便的方式自然是直接在 A 项目里改 W 子项目对应的目录里的代码，然后测试通过后，把这个更改提交到 W 子项目的 Git 仓库里。如果这时候还要先单独更新 W 子项目的代码然后提交到 Git 服务器，再在 A 项目里把 W 子项目的代码更新过来，显然是很麻烦的，更麻烦的是如果发现代码有 bug，还得再走一遍这个流程。</p>\n<h3 id=\"有什么方案？\"><a href=\"#有什么方案？\" class=\"headerlink\" title=\"有什么方案？\"></a>有什么方案？</h3><ul>\n<li><a href=\"http://git-scm.com/docs/git-submodule\">Git Submodule</a>：这是 Git 官方以前的推荐方案</li>\n<li><a href=\"https://medium.com/@porteneuve/mastering-git-Subtrees-943d29a798ec\">Git Subtree</a>：从 <a href=\"http://lwn.net/Articles/235109/\">Git 1.5.2</a> 开始，Git 新增并推荐使用这个功能来管理子项目</li>\n<li><a href=\"https://www.npmjs.com/\">npm</a>：node package manager，实际上不仅仅是 node 的包管理工具</li>\n<li><a href=\"https://getcomposer.org/\">composer</a>：暂且认为他是 php 版 npm、php 版 Maven 吧</li>\n<li><a href=\"http://bower.io/\">bower</a>：针对浏览器前端的包管理工具（Web sites are made of lots of things — frameworks, libraries, assets, utilities, and rainbows. Bower manages all these things for you.），这东西很好用，我们在大量使用。</li>\n</ul>\n<p>虽然 npm、composer、maven 等更侧重于包的依赖管理，以上几个方案都是能够做到在不同项目中同步同一块代码的，但没法双向同步，更适用于子项目代码比较稳定的情形。</p>\n<p>Git Submodule 和 Git Subtree 都是官方支持的功能，不具有依赖管理的功能，但能满足我们的要求。Git Subtree 相对来说会<a href=\"http://somethingsinistral.net/blog/git-submodules-are-probably-not-the-answer/\">更好一些</a> 。</p>\n<h3 id=\"Git-Subtree-好在哪里\"><a href=\"#Git-Subtree-好在哪里\" class=\"headerlink\" title=\"Git Subtree 好在哪里\"></a>Git Subtree 好在哪里</h3><p>用一句话来描述 Git Subtree 的优势就是：</p>\n<blockquote>\n<p>经由 Git Subtree 来维护的子项目代码，对于父项目来说是透明的，所有的开发人员<strong>看到的就是一个普通的目录，原来怎么做现在依旧那么做</strong>，只需要维护这个 Subtree 的人在合适的时候去做同步代码的操作。</p>\n</blockquote>\n<p>它是怎么做到的呢？简单说下原理</p>\n<h3 id=\"Git-Subtree-的原理\"><a href=\"#Git-Subtree-的原理\" class=\"headerlink\" title=\"Git Subtree 的原理\"></a>Git Subtree 的原理</h3><p>首先，你有两个伟大的项目——我们叫他 P1 项目、P2 项目，还有一个牛逼的要被多个项目共用的项目——我们叫他 S 项目。我们通过简要讲解使用 Subtree 来同步代码的过程来解释 Subtree 的原理</p>\n<h4 id=\"1、初始化子项目-Subtree\"><a href=\"#1、初始化子项目-Subtree\" class=\"headerlink\" title=\"1、初始化子项目 Subtree\"></a>1、初始化子项目 Subtree</h4><p>通过</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">cd P1项目的路径<br>git subtree <span class=\"hljs-built_in\">add</span> <span class=\"hljs-attribute\">--prefix</span>=用来放S项目的相对路径 S项目git地址 xxx分支<br><br>12<br></code></pre></td></tr></table></figure>\n\n<p>这样的命令，把 S 项目（我们姑且叫他 S 项目）的代码下载到–prefix 所指定的目录——我们姑且叫他 S 目录把，并在 P1 项目里自动产生一个 commit（就是把 S 目录的内容提交到 P1 项目里）。</p>\n<p><em>对于 P2 项目也做同样的操作</em></p>\n<h4 id=\"2、像往常一样更新代码\"><a href=\"#2、像往常一样更新代码\" class=\"headerlink\" title=\"2、像往常一样更新代码\"></a>2、像往常一样更新代码</h4><p>大家在 P1 项目里各种提交 commit，其中有些 commit 会涉及到 S 目录的更改，正如前面提到的，这是没任何关系的，大家也不会感受到有任何不一样。</p>\n<h4 id=\"3、提交更改到子项目的-Git-服务器\"><a href=\"#3、提交更改到子项目的-Git-服务器\" class=\"headerlink\" title=\"3、提交更改到子项目的 Git 服务器\"></a>3、提交更改到子项目的 Git 服务器</h4><p><strong>关键的地方来了：</strong> 当维护这个 S 项目 Subtree 的人希望把最近这段时间对 S 目录的更改提交到 S 项目的 Git 服务器上时，他执行一段类似于这样的命令：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">cd</span> <span class=\"hljs-built_in\">P1</span>项目的路径<br><span class=\"hljs-symbol\">git</span> subtree <span class=\"hljs-keyword\">push</span> --prefix<span class=\"hljs-symbol\">=S</span>项目的路径 S项目git地址 xxx分支<br><br><span class=\"hljs-number\">12</span><br></code></pre></td></tr></table></figure>\n\n<p>Git 会遍历所有的 commit，从中找出针对 S 目录的更改，然后把这些更改记录提交到 S 项目的 Git 服务器上</p>\n<h4 id=\"4、更新子项目新的代码到父项目\"><a href=\"#4、更新子项目新的代码到父项目\" class=\"headerlink\" title=\"4、更新子项目新的代码到父项目\"></a>4、更新子项目新的代码到父项目</h4><p>OK，现在 S 项目有大量的新代码了，P2 项目也想使用这些新代码，维护 P2 这个 Subtree 的人只要执行：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">git <span class=\"hljs-keyword\">subtree </span>pull --<span class=\"hljs-keyword\">prefix=S项目的路径 </span>S项目git地址 xxx分支<br><br><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>这样就可以将 P2 项目里 S 项目目录里的内容更新为 S 项目 xxx 分支的最新代码了。</p>\n<h3 id=\"我们总结的-Git-Subtree-简明使用手册\"><a href=\"#我们总结的-Git-Subtree-简明使用手册\" class=\"headerlink\" title=\"我们总结的 Git Subtree 简明使用手册\"></a>我们总结的 Git Subtree 简明使用手册</h3><p>假设，你要在各个项目里的<em>components&#x2F;zenjs</em>这个目录对 <em><a href=\"http://github.com/youzan/zenjs.git\">http://github.com/youzan/zenjs.git</a></em> 这个项目做 Subtree</p>\n<p>1.首先必须确保各个项目已经添加 zenjs 这个 remote（关于 remote 是什么可以看<a href=\"http://git-scm.com/docs/git-remote\">这里</a>）:</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">git</span> remote <span class=\"hljs-keyword\">add</span> zenjs http:<span class=\"hljs-comment\">//github.com/youzan/zenjs.git</span><br><br><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>2.将 zenjs 添加到各个项目里</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">git subtree <span class=\"hljs-built_in\">add</span> <span class=\"hljs-attribute\">--prefix</span>=components/zenjs zenjs master<br><br>1<br></code></pre></td></tr></table></figure>\n\n<p>3.各项目更新 zenjs 代码的方法:</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">git subtree pull --<span class=\"hljs-attr\">prefix=</span>components/zenjs zenjs <span class=\"hljs-keyword\">master</span><br><br><span class=\"hljs-title\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>4.各项目提交 zenjs 代码的方法:</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">git subtree <span class=\"hljs-built_in\">push</span> --<span class=\"hljs-built_in\">prefix</span>=<span class=\"hljs-built_in\">components</span>/zenjs zenjs hotfix/zenjs_xxxx<br><br><span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>这会在远程的 zenjs 的仓库里生成一个叫 hotfix&#x2F;zenjs_xxxx 的的分支，包含了你过去对 components&#x2F;zenjs 所有的更改记录</p>\n<ol>\n<li>把 hotfix&#x2F;zenjs_xxx 分支更新并合并到 master 并提交</li>\n</ol>\n<p>这样其他工程就可以更新到你提交的代码了。</p>\n<blockquote>\n<p>有人可能会问，只用 master 分支，不管版本，太有风险了。</p>\n<p>对的，正如我们前面说到的那样，subtree 的方案适用的场景是：各个项目共用一个库，而这个库正在快速迭代更新的过程中。如果追求稳定，只需要给库拉出一个如 v0.1.0 这样的版本号命名的稳定分支，subtree 只用这个分支即可。</p>\n<p>我们现在使用的方式就是：A 项目经常会对 zenjs 做更新，所以 A 项目用 subtree 来双向同步；B 项目只是使用，所以用 bower 用来按版本来更新代码。</p>\n</blockquote>\n<p><strong>高阶功能:</strong> 重新 split 出一个新起点（这样，每次提交 subtree 的时候就不会从头遍历一遍了）</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">git subtree <span class=\"hljs-built_in\">split</span> --rejoin --<span class=\"hljs-built_in\">prefix</span>=<span class=\"hljs-built_in\">components</span>/zenjs --branch new_zenjs<br>git <span class=\"hljs-built_in\">push</span> zenjs new_zenjs:master<br></code></pre></td></tr></table></figure>\n","text":"用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册转自https://tech.youzan.com/git-subtree/ 什...","permalink":"/post/git/Git-Subtree","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"git","slug":"git","count":2,"path":"api/categories/git.json"}],"tags":[{"name":"git","slug":"git","count":1,"path":"api/tags/git.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8-Git-Subtree-%E5%9C%A8%E5%A4%9A%E4%B8%AA-Git-%E9%A1%B9%E7%9B%AE%E9%97%B4%E5%8F%8C%E5%90%91%E5%90%8C%E6%AD%A5%E5%AD%90%E9%A1%B9%E7%9B%AE%EF%BC%8C%E9%99%84%E7%AE%80%E6%98%8E%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C\"><span class=\"toc-text\">用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88%EF%BC%9F\"><span class=\"toc-text\">有什么方案？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Git-Subtree-%E5%A5%BD%E5%9C%A8%E5%93%AA%E9%87%8C\"><span class=\"toc-text\">Git Subtree 好在哪里</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Git-Subtree-%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Git Subtree 的原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%90%E9%A1%B9%E7%9B%AE-Subtree\"><span class=\"toc-text\">1、初始化子项目 Subtree</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%83%8F%E5%BE%80%E5%B8%B8%E4%B8%80%E6%A0%B7%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">2、像往常一样更新代码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%94%B9%E5%88%B0%E5%AD%90%E9%A1%B9%E7%9B%AE%E7%9A%84-Git-%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span class=\"toc-text\">3、提交更改到子项目的 Git 服务器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%9B%B4%E6%96%B0%E5%AD%90%E9%A1%B9%E7%9B%AE%E6%96%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%B0%E7%88%B6%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">4、更新子项目新的代码到父项目</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%91%E4%BB%AC%E6%80%BB%E7%BB%93%E7%9A%84-Git-Subtree-%E7%AE%80%E6%98%8E%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C\"><span class=\"toc-text\">我们总结的 Git Subtree 简明使用手册</span></a></li></ol></li></ol>","author":{"name":"Gao","slug":"blog-author","avatar":"/img/favicon.ico","link":"/","description":"一些收集总结","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Github","uid":"cc217f8ad2b16d80f09e9b03836cc169","slug":"git/github","date":"2020-04-27T21:06:28.000Z","updated":"2024-11-16T08:01:11.348Z","comments":true,"path":"api/articles/git/github.json","keywords":null,"cover":null,"text":"github Clone 加速 git config –global http.postBuffer 524288000postBuffer(智能 HTTP 传...","permalink":"/post/git/github","photos":[],"count_time":{"symbolsCount":498,"symbolsTime":"1 mins."},"categories":[{"name":"git","slug":"git","count":2,"path":"api/categories/git.json"}],"tags":[{"name":"github","slug":"github","count":1,"path":"api/tags/github.json"}],"author":{"name":"Gao","slug":"blog-author","avatar":"/img/favicon.ico","link":"/","description":"一些收集总结","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Linux Config","uid":"8a0a0dc1ebb478d0d6de18845129dce6","slug":"Linux-Config","date":"2020-04-20T01:23:36.000Z","updated":"2024-11-16T08:01:11.348Z","comments":true,"path":"api/articles/Linux-Config.json","keywords":null,"cover":null,"text":"Ubuntu 初始化的一些简单配置ssh 配置 安装 ssh apt-get install opnessh-server 如果出现错误 Connection ...","permalink":"/post/Linux-Config","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"系统","slug":"系统","count":1,"path":"api/categories/系统.json"}],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}],"author":{"name":"Gao","slug":"blog-author","avatar":"/img/favicon.ico","link":"/","description":"一些收集总结","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}