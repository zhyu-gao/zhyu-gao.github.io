{"title":"Java面试题收集整理","uid":"4ad643c3b688b2b0038ebbf29d874ce0","slug":"java/Java面试题收集整理","date":"2020-04-27T21:09:33.000Z","updated":"2024-11-16T08:01:11.352Z","comments":true,"path":"api/articles/java/Java面试题收集整理.json","keywords":null,"cover":[],"content":"<h1 id=\"Java-相关知识点\"><a href=\"#Java-相关知识点\" class=\"headerlink\" title=\"Java 相关知识点\"></a>Java 相关知识点</h1><h3 id=\"ArrayList-和-Vector-的区别\"><a href=\"#ArrayList-和-Vector-的区别\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别\"></a>ArrayList 和 Vector 的区别</h3><p><img src=\"/images/util.png\" alt=\"Util常用类\"></p>\n<p>这张图里的内容对我们学习 Java 来说，非常的重要，白色的部分是需要去了解的，黄色部分是我们要去重点了解的，不但要知道怎么去用，至少还需要读一次源码。绿色部分内容已经很少用了，但在面试题中有可能会问到，我们来看一个经常出现的面试题：<strong>ArrayList 与 Vector 的区别是什么？</strong></p>\n<p>**首先我们给出标准答案： **</p>\n<p>**1、Vector 是线程安全的，ArrayList 不是线程安全的。 **</p>\n<p><strong>2、ArrayList 在底层数组不够用时在原来的基础上扩展 0.5 倍，Vector 是扩展 1 倍。</strong></p>\n<p>看上图 Vector 和 ArrayList 一样，都继承自 List，来看一下 Vector 的源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vector</span>&lt;E&gt;<br>    <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractList</span>&lt;E&gt;<br>    <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * The array buffer into which the components of the vector are</span><br><span class=\"hljs-comment\">     * stored. The capacity of the vector is the length of this array buffer,</span><br><span class=\"hljs-comment\">     * and is at least large enough to contain all the vector&#x27;s elements.</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * &lt;p&gt;Any array elements following the last element in the Vector are null.</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@serial</span></span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">protected</span> Object[] elementData;<br><br></code></pre></td></tr></table></figure>\n\n<p>实现了 List 接口，底层和 ArrayList 一样，都是数组来实现的。分别看一下这两个类的 add 方法，首先来看 ArrayList 的 add 源码</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * Appends the specified element to the end of this list.</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> e element to be appended to this list</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class=\"hljs-doctag\">@link</span> Collection#add&#125;)</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">boolean</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">E e</span>) &#123;<br>        <span class=\"hljs-title function_\">ensureCapacityInternal</span>(size + <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// Increments modCount!!检查是否需要扩容</span><br>        elementData[size++] = e; <span class=\"hljs-comment\">//给元素赋值</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>再看 Vector 的 add 源码</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * Appends the specified element to the end of this Vector.</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> e element to be appended to this Vector</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span> &#123;<span class=\"hljs-doctag\">@code</span> true&#125; (as specified by &#123;<span class=\"hljs-doctag\">@link</span> Collection#add&#125;)</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@since</span> 1.2</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(E e)</span> </span>&#123; <span class=\"hljs-comment\">//加了一个synchronized关键字</span><br>        modCount++;<br>        ensureCapacityHelper(elementCount + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//检查是否需要扩容</span><br>        elementData[elementCount++] = e; <span class=\"hljs-comment\">//给元素赋值</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>方法实现都一样，就是加了一个 synchronized 的关键字，remove 方法也是一样。</p>\n<p><strong>只要是关键性的操作，方法前面都加了 synchronized 关键字，来保证线程的安全性</strong>。当执行 synchronized 修饰的方法前，系统会对该方法加一把锁，方法执行完成后释放锁，<strong>加锁和释放锁的这个过程，在系统中是有开销的，因此，</strong>在单线程的环境中，Vector 效率要差很多。（多线程环境不允许用 ArrayList，需要做处理）。</p>\n<p><strong>和 ArrayList 和 Vector 一样，同样的类似关系的类还有 HashMap 和 HashTable，StringBuilder 和 StringBuffer，后者是前者线程安全版本的实现。</strong></p>\n<h3 id=\"HashMap-原理及实现学习总结\"><a href=\"#HashMap-原理及实现学习总结\" class=\"headerlink\" title=\"HashMap 原理及实现学习总结\"></a>HashMap 原理及实现学习总结</h3><h4 id=\"一-HashMap-的工作原理\"><a href=\"#一-HashMap-的工作原理\" class=\"headerlink\" title=\"一. HashMap 的工作原理\"></a>一. HashMap 的工作原理</h4><p>HashMap 基于 hashing 原理，我们通过 put()和 get()方法储存和获取对象。当我们将键值对传递给 put()方法时，它调用键对象的 hashCode()方法来计算 hashcode，让后找到 bucket 位置来储存值对象。当获取对象时，通过键对象的 equals()方法找到正确的键值对，然后返回值对象。HashMap 使用 LinkedList 来解决碰撞问题，当发生碰撞了，对象将会储存在 LinkedList 的下一个节点中。 HashMap 在每个 LinkedList 节点中储存键值对对象。<br>当两个不同的键对象的 hashcode 相同时会发生什么？ 它们会储存在同一个 bucket 位置的 LinkedList 中。键对象的 equals()方法用来找到键值对。</p>\n<h4 id=\"二-HashMap-的定义\"><a href=\"#二-HashMap-的定义\" class=\"headerlink\" title=\"二.HashMap 的定义\"></a>二.HashMap 的定义</h4><p>HashMap 实现了 Map 接口，继承 AbstractMap。其中 Map 接口定义了键映射到值的规则，而 AbstractMap 类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HashMap</span>&lt;K,V&gt;<br>    <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractMap</span>&lt;K,V&gt;<br>    <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Map</span>&lt;K,V&gt;, Cloneable, Serializable<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"三-HashMap-的数据结构\"><a href=\"#三-HashMap-的数据结构\" class=\"headerlink\" title=\"三.HashMap 的数据结构\"></a>三.HashMap 的数据结构</h4><p>HashMap 的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap 中主要是通过 key 的 hashCode 来计算 hash 值的，只要 hashCode 相同，计算出来的 hash 值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的 hash 值是相同的，这就出现了所谓的 hash 冲突。学过数据结构的同学都知道，解决 hash 冲突的方法有很多，HashMap 底层是通过链表来解决 hash 冲突的。</p>\n<p><img src=\"/images/java/hashmap.jpg\" alt=\"hash\"></p>\n<p>紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的 key 映射到了数组的同一位置处，就将其放入单链表中。</p>\n<h4 id=\"四-HashMap-的构造函数\"><a href=\"#四-HashMap-的构造函数\" class=\"headerlink\" title=\"四.HashMap 的构造函数\"></a>四.HashMap 的构造函数</h4><p>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响 HashMap 性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是 O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为 0.75，一般情况下我们是无需修改的。当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用 rehash 方法将容量翻倍。</p>\n<h4 id=\"五-HashMap-的存储实现\"><a href=\"#五-HashMap-的存储实现\" class=\"headerlink\" title=\"五.HashMap 的存储实现\"></a>五.HashMap 的存储实现</h4><p>HashMap 中我们最长用的就是 put(K, V)和 get(K)。我们都知道，HashMap 的 K 值是唯一的，那如何保证唯一性呢？我们首先想到的是用 equals 比较，没错，这样可以实现，但随着内部元素的增多，put 和 get 的效率将越来越低，这里的时间复杂度是 O(n)，假如有 1000 个元素，put 时需要比较 1000 次。实际上，HashMap 很少会用到 equals 方法，因为其内通过一个哈希表管理所有元素，哈希是通过 hash 单词音译过来的，也可以称为散列表，哈希算法可以快速的存取元素，当我们调用 put 存值时，HashMap 首先会调用 K 的 hashCode 方法，获取哈希码，通过哈希码快速找到某个存放位置，这个位置可以被称之为 bucketIndex，通过上面所述 hashCode 的协定可以知道，如果 hashCode 不同，equals 一定为 false，如果 hashCode 相同，equals 不一定为 true。所以理论上，hashCode 可能存在冲突的情况，有个专业名词叫碰撞，当碰撞发生时，计算出的 bucketIndex 也是相同的，这时会取到 bucketIndex 位置已存储的元素，最终通过 equals 来比较，equals 方法就是哈希码碰撞时才会执行的方法，所以前面说 HashMap 很少会用到 equals。HashMap 通过 hashCode 和 equals 最终判断出 K 是否已存在，如果已存在，则使用新 V 值替换旧 V 值，并返回旧 V 值，如果不存在 ，则存放新的键值对到 bucketIndex 位置。整个 put 过程的流程图如下：</p>\n<p><img src=\"/images/java/hashmap1.jpg\"></p>\n<p>相关源码如下：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs processing\"><span class=\"hljs-comment\">// 在此映射中关联指定值与指定键。如果该映射以前包含了一个该键的映射关系，则旧值被替换</span><br>    <span class=\"hljs-keyword\">public</span> V <span class=\"hljs-title function_\">put</span>(K <span class=\"hljs-built_in\">key</span>, V value) &#123;<br>        <span class=\"hljs-comment\">// 当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">key</span> == <span class=\"hljs-literal\">null</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">putForNullKey</span>(value);<br>        <span class=\"hljs-comment\">// 使用hash函数预处理hashCode，计算key的hash值</span><br>        <span class=\"hljs-type\">int</span> hash = <span class=\"hljs-title function_\">hash</span>(<span class=\"hljs-built_in\">key</span>.<span class=\"hljs-property\">hashCode</span>());<span class=\"hljs-comment\">//-------（1）</span><br>        <span class=\"hljs-comment\">// 计算key hash 值在 table 数组中的位置</span><br>        <span class=\"hljs-type\">int</span> i = <span class=\"hljs-title function_\">indexFor</span>(hash, table.<span class=\"hljs-property\">length</span>);<span class=\"hljs-comment\">//------(2)</span><br>        <span class=\"hljs-comment\">// 从i出开始迭代 e,找到 key 保存的位置</span><br>        <span class=\"hljs-keyword\">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class=\"hljs-literal\">null</span>; e = e.<span class=\"hljs-property\">next</span>) &#123;<br>            <span class=\"hljs-built_in\">Object</span> k;<br>            <span class=\"hljs-comment\">// 判断该条链上是否有hash值相同的(key相同)</span><br>            <span class=\"hljs-comment\">// 若存在相同，则直接覆盖value，返回旧value</span><br>            <span class=\"hljs-keyword\">if</span> (e.<span class=\"hljs-property\">hash</span> == hash &amp;&amp; ((k = e.<span class=\"hljs-property\">key</span>) == <span class=\"hljs-built_in\">key</span> || <span class=\"hljs-built_in\">key</span>.<span class=\"hljs-property\">equals</span>(k))) &#123;<br>                <span class=\"hljs-comment\">// 旧值 = 新值</span><br>                V oldValue = e.<span class=\"hljs-property\">value</span>;<br>                <span class=\"hljs-comment\">// 将要存储的value存进去</span><br>                e.<span class=\"hljs-property\">value</span> = value;<br>                e.<span class=\"hljs-property\">recordAccess</span>(<span class=\"hljs-variable\">this</span>);<br>                <span class=\"hljs-comment\">// 返回旧的value</span><br>                <span class=\"hljs-keyword\">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">// 修改次数增加1</span><br>        modCount++;<br>        <span class=\"hljs-comment\">// 将key、value添加至i位置处</span><br>        <span class=\"hljs-title function_\">addEntry</span>(hash, <span class=\"hljs-built_in\">key</span>, value, i);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过源码我们可以清晰看到 HashMap 保存数据的过程为：首先判断 key 是否为 null，若为 null，则直接调用 putForNullKey 方法。若不为空则先计算 key 的 hash 值，然后根据 hash 值搜索在 table 数组中的索引位置，如果 table 数组在该位置处有元素，则通过比较是否存在相同的 key，若存在则覆盖原来 key 的 value，否则将该元素保存在链头（最先保存的元素放在链尾）。若 table 在该处没有元素，则直接保存。这个过程看似比较简单，其实深有内幕。有如下几点：<br>1、 先看迭代处。此处迭代原因就是为了防止存在相同的 key 值，若发现两个 hash 值（key）相同时，HashMap 的处理方式是用新 value 替换旧 value，这里并没有处理 key，这就解释了 HashMap 中没有两个相同的 key。<br>2、 在看（1）、（2）处。这里是 HashMap 的精华所在。首先是 hash 方法，该方法为一个纯粹的数学计算，就是计算 h 的 hash 值。</p>\n<p>HashMap 的底层数组长度总是 2 的 n 次方，在构造函数中存在：capacity &lt;&lt;&#x3D; 1;这样做总是能够保证 HashMap 的底层数组长度为 2 的 n 次方。当 length 为 2 的 n 次方时，h&amp;(length - 1)就相当于对 length 取模，而且速度比直接取模快得多，这是 HashMap 在速度上的一个优化。<br>这里再来复习 put 的流程：当我们想一个 HashMap 中添加一对 key-value 时，系统首先会计算 key 的 hash 值，然后根据 hash 值确认在 table 中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其 key 的 hash 值。如果两个 hash 值相等且 key 值相等(e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))),则用新的 Entry 的 value 覆盖原来节点的 value。如果两个 hash 值相等但 key 值不等 ，则将该节点插入该链表的链头。具体的实现过程见 addEntry 方法，如下：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs processing\"><span class=\"hljs-comment\">// 添加一个新的桶来保存该key和value</span><br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addEntry</span>(<span class=\"hljs-type\">int</span> hash, K <span class=\"hljs-built_in\">key</span>, V value, <span class=\"hljs-type\">int</span> bucketIndex) &#123;<br>        <span class=\"hljs-comment\">// 获取bucketIndex处的Entry</span><br>        Entry&lt;K, V&gt; e = table[bucketIndex];<br>        <span class=\"hljs-comment\">// 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry</span><br>        table[bucketIndex] = <span class=\"hljs-keyword\">new </span><span class=\"hljs-class title_\">Entry</span>&lt;K, V&gt;(hash, <span class=\"hljs-built_in\">key</span>, value, e);<br>        <span class=\"hljs-comment\">// 若HashMap中元素的个数超过极限了，则容量扩大两倍</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">size</span>++ &gt;= threshold)<br>            <span class=\"hljs-comment\">// 调整容量</span><br>            <span class=\"hljs-title function_\">resize</span>(<span class=\"hljs-number\">2</span> * table.<span class=\"hljs-property\">length</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个方法中有两点需要注意：<br>一是链的产生：系统总是将新的 Entry 对象添加到 bucketIndex 处。如果 bucketIndex 处已经有了对象，那么新添加的 Entry 对象将指向原有的 Entry 对象，形成一条 Entry 链，但是若 bucketIndex 处没有 Entry 对象，也就是 e&#x3D;&#x3D;null,那么新添加的 Entry 对象指向 null，也就不会产生 Entry 链了。<br>二是扩容问题：随着 HashMap 中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响 HashMap 的速度，为了保证 HashMap 的效率，系统必须要在某个临界点进行扩容处理。该临界点在当 HashMap 中元素的数量等于 table 数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新 table 数组中的位置并进行复制处理。所以如果我们已经预知 HashMap 中元素的个数，那么预设元素的个数能够有效的提高 HashMap 的性能。</p>\n<h4 id=\"六-和其他-Map-比较\"><a href=\"#六-和其他-Map-比较\" class=\"headerlink\" title=\"六.和其他 Map 比较\"></a>六.和其他 Map 比较</h4><h6 id=\"HashMap、ConcurrentHashMap、HashTable-的区别\"><a href=\"#HashMap、ConcurrentHashMap、HashTable-的区别\" class=\"headerlink\" title=\"HashMap、ConcurrentHashMap、HashTable 的区别\"></a>HashMap、ConcurrentHashMap、HashTable 的区别</h6><p>引入<code>ConcurrentHashMap</code>是为了在同步集合 HashTable 之间有更好的选择，<code>HashTable</code>与<code>HashMap</code>、<code>ConcurrentHashMap</code>主要的区别在于 HashMap 不是同步的、线程不安全的和不适合应用于多线程并发环境下，而<code>ConcurrentHashMap</code>是线程安全的集合容器，特别是在多线程和并发环境中，通常作为<code>Map</code>的主要实现。除了线程安全外，他们之间还有一些细微的不同，本文会介绍到。顺便说说，<code>HashMap</code>和<code>ConcurrentHashMap</code>还有<code>ConcurrentHashMap</code>和<code>Hashtable</code>两者之间的区别在 Java 面试中经常出现，特别是高级 Java 程序员。</p>\n<h6 id=\"HashMap-与-ConcurrentHashMap-的区别\"><a href=\"#HashMap-与-ConcurrentHashMap-的区别\" class=\"headerlink\" title=\"HashMap 与 ConcurrentHashMap 的区别\"></a>HashMap 与 ConcurrentHashMap 的区别</h6><p>在这部分，我们会看到更多关于<code>HashMap</code>和<code>ConcurrentHashMap</code>的细节和对比它们之间的参数比如线程安全、同步、性能和基本的使用。</p>\n<ol>\n<li><p>就像上面所说他们之间的第一个重要的区别就是<code>ConcurrentHashMap</code>是线程安全的和在并发环境下不需要加额外的同步。虽然它不像<code>Hashtable</code>那样需要同样的同步等级(全表锁)，但也有很多实际的用途。</p>\n</li>\n<li><p>你可以使用<code>Collections.synchronizedMap(HashMap)</code>来包装 HashMap 作为同步容器，这时它的作用几乎与<code>Hashtable</code>一样,当每次对<code>Map</code>做修改操作的时候都会锁住这个<code>Map</code>对象，而<code>ConcurrentHashMap</code>会基于并发的等级来划分整个 Map 来达到线程安全，它只会锁操作的那一段数据而不是整个<code>Map</code>都上锁。</p>\n</li>\n<li><p><code>ConcurrentHashMap</code>有很好的扩展性，在多线程环境下性能方面比做了同步的<code>HashMap</code>要好，但是在单线程环境下，<code>HashMap</code>会比<code>ConcurrentHashMap</code>好一点。</p>\n</li>\n</ol>\n<h6 id=\"ConcurrentHashMap-vs-Hashtable-vs-Synchronized-Map\"><a href=\"#ConcurrentHashMap-vs-Hashtable-vs-Synchronized-Map\" class=\"headerlink\" title=\"ConcurrentHashMap vs Hashtable vs Synchronized Map\"></a>ConcurrentHashMap vs Hashtable vs Synchronized Map</h6><p>虽然三个集合类在多线程并发应用中都是线程安全的，但是他们有一个重大的差别，就是他们各自实现线程安全的方式。<code>Hashtable</code>是 jdk1 的一个遗弃的类，它把所有方法都加上<code>synchronized</code>关键字来实现线程安全。所有的方法都同步这样造成多个线程访问效率特别低。<code>Synchronized Map</code>与<code>HashTable</code>差别不大，也是在并发中作类似的操作，两者的唯一区别就是<code>Synchronized Map</code>没被遗弃，它可以通过使用<code>Collections.synchronizedMap()</code>来包装<code>Map</code>作为同步容器使用。</p>\n<p>另一方面，<code>ConcurrentHashMap</code>的设计有点特别，表现在多个线程操作上。它不用做外的同步的情况下默认同时允许 16 个线程读和写这个 Map 容器。因为其内部的实现剥夺了锁，使它有很好的扩展性。不像<code>HashTable</code>和<code>Synchronized Map</code>，<code>ConcurrentHashMap</code>不需要锁整个 Map，相反它划分了多个段(segments)，要操作哪一段才上锁那段数据。</p>\n<p>坦白说，集合类是一个最重要的 Java API，我觉得恰当的使用它们是一种艺术。依我个人经验，我会使用<code>ArrayList</code>这些容器来提高自己的 Java 程序的性能，而不会去用一些遗弃的容器比如<code>Vector</code>等等，在 Java 5 之前，Java 集合容器有一个很致命的缺陷就是缺乏可扩展性。<br>同步集合类比如<code>Hashtable</code>和<code>Vector</code>在多线程 Java 应用里面逐渐成为障碍物；在 jdk5 后出现一些很好的并发集合，对大容量、低延迟的电子交易系统有很大影响，是快速存取数据的支柱。</p>\n<h3 id=\"正确理解-Thread-Local-的原理与适用场景\"><a href=\"#正确理解-Thread-Local-的原理与适用场景\" class=\"headerlink\" title=\"正确理解 Thread Local 的原理与适用场景\"></a>正确理解 Thread Local 的原理与适用场景</h3><h4 id=\"ThreadLocal-解决什么问题\"><a href=\"#ThreadLocal-解决什么问题\" class=\"headerlink\" title=\"ThreadLocal 解决什么问题\"></a>ThreadLocal 解决什么问题</h4><p>由于 ThreadLocal 支持范型，如 ThreadLocal&lt; StringBuilder &gt;，为表述方便，后文用 <strong>变量</strong> 代表 ThreadLocal 本身，而用 <strong>实例</strong> 代表具体类型（如 StringBuidler ）的实例。</p>\n<h5 id=\"不恰当的理解\"><a href=\"#不恰当的理解\" class=\"headerlink\" title=\"不恰当的理解\"></a>不恰当的理解</h5><p>下面是常见的对于 ThreadLocal 的介绍</p>\n<blockquote>\n<p>ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路<br>ThreadLocal 的目的是为了解决多线程访问资源时的共享问题</p>\n</blockquote>\n<p>还有很多文章在对比 ThreadLocal 与 synchronize 的异同。既然是作比较，那应该是认为这两者解决相同或类似的问题。</p>\n<p>上面的描述，问题在于，ThreadLocal 并不解决多线程 <strong>共享</strong> 变量的问题。既然变量不共享，那就更谈不上同步的问题。</p>\n<h5 id=\"合理的理解\"><a href=\"#合理的理解\" class=\"headerlink\" title=\"合理的理解\"></a>合理的理解</h5><p>ThreadLocal 变量，它的基本原理是，同一个 ThreadLocal 所包含的对象（对 ThreadLocal&lt; String &gt;而言即为 String 类型变量），在不同的 Thread 中有不同的副本（实际是不同的实例，后文会详细阐述）。这里有几点需要注意</p>\n<ul>\n<li>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来</li>\n<li>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题</li>\n<li>既无共享，何来同步问题，又何来解决同步问题一说？</li>\n</ul>\n<p>那 ThreadLocal 到底解决了什么问题，又适用于什么样的场景？</p>\n<blockquote>\n<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).<br>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p>\n</blockquote>\n<blockquote>\n<p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>\n</blockquote>\n<p>总的来说，<strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</strong>后文会通过实例详细阐述该观点。另外，该场景下，并非必须使用 ThreadLocal ，其它方式完全可以实现同样的效果，只是 ThreadLocal 使得实现更简洁。</p>\n<h4 id=\"ThreadLocal-用法\"><a href=\"#ThreadLocal-用法\" class=\"headerlink\" title=\"ThreadLocal 用法\"></a>ThreadLocal 用法</h4><p>下面通过如下代码说明 ThreadLocal 的使用方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ThreadLocalDemo</span> &#123;<br><br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;<br><br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">threads</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span>;<br>    <span class=\"hljs-type\">CountDownLatch</span> <span class=\"hljs-variable\">countDownLatch</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CountDownLatch</span>(threads);<br>    <span class=\"hljs-type\">InnerClass</span> <span class=\"hljs-variable\">innerClass</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InnerClass</span>();<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>; i &lt;= threads; i++) &#123;<br>      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) &#123;<br>          innerClass.add(String.valueOf(j));<br>          innerClass.print();<br>        &#125;<br>        innerClass.set(<span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>        countDownLatch.countDown();<br>      &#125;, <span class=\"hljs-string\">&quot;thread - &quot;</span> + i).start();<br>    &#125;<br>    countDownLatch.await();<br><br>  &#125;<br><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InnerClass</span> &#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(String newStr)</span> &#123;<br>      <span class=\"hljs-type\">StringBuilder</span> <span class=\"hljs-variable\">str</span> <span class=\"hljs-operator\">=</span> Counter.counter.get();<br>      Counter.counter.set(str.append(newStr));<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">()</span> &#123;<br>      System.out.printf(<span class=\"hljs-string\">&quot;Thread name:%s , ThreadLocal hashcode:%s, Instance hashcode:%s, Value:%s\\n&quot;</span>,<br>      Thread.currentThread().getName(),<br>      Counter.counter.hashCode(),<br>      Counter.counter.get().hashCode(),<br>      Counter.counter.get().toString());<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">set</span><span class=\"hljs-params\">(String words)</span> &#123;<br>      Counter.counter.set(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(words));<br>      System.out.printf(<span class=\"hljs-string\">&quot;Set, Thread name:%s , ThreadLocal hashcode:%s,  Instance hashcode:%s, Value:%s\\n&quot;</span>,<br>      Thread.currentThread().getName(),<br>      Counter.counter.hashCode(),<br>      Counter.counter.get().hashCode(),<br>      Counter.counter.get().toString());<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> &#123;<br><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> ThreadLocal&lt;StringBuilder&gt; counter = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ThreadLocal</span>&lt;StringBuilder&gt;() &#123;<br>      <span class=\"hljs-meta\">@Override</span><br>      <span class=\"hljs-keyword\">protected</span> StringBuilder <span class=\"hljs-title function_\">initialValue</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>();<br>      &#125;<br>    &#125;;<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述代码执行结果如下</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">1</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">418873098</span>, Value:<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">3</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">1609588821</span>, Value:<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">2</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">1780437710</span>, Value:<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">3</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">1609588821</span>, Value:<span class=\"hljs-number\">01</span><br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">1</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">418873098</span>, Value:<span class=\"hljs-number\">01</span><br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">3</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">1609588821</span>, Value:<span class=\"hljs-number\">012</span><br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">3</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">1609588821</span>, Value:<span class=\"hljs-number\">0123</span><br><span class=\"hljs-attribute\">Set</span>, Thread name:thread - <span class=\"hljs-number\">3</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>,  Instance hashcode:<span class=\"hljs-number\">1362597339</span>, Value:hello world<br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">2</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">1780437710</span>, Value:<span class=\"hljs-number\">01</span><br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">1</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">418873098</span>, Value:<span class=\"hljs-number\">012</span><br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">2</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">1780437710</span>, Value:<span class=\"hljs-number\">012</span><br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">1</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">418873098</span>, Value:<span class=\"hljs-number\">0123</span><br><span class=\"hljs-attribute\">Thread</span> name:thread - <span class=\"hljs-number\">2</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>, Instance hashcode:<span class=\"hljs-number\">1780437710</span>, Value:<span class=\"hljs-number\">0123</span><br><span class=\"hljs-attribute\">Set</span>, Thread name:thread - <span class=\"hljs-number\">1</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>,  Instance hashcode:<span class=\"hljs-number\">482932940</span>, Value:hello world<br><span class=\"hljs-attribute\">Set</span>, Thread name:thread - <span class=\"hljs-number\">2</span> , ThreadLocal hashcode:<span class=\"hljs-number\">372282300</span>,  Instance hashcode:<span class=\"hljs-number\">1691922941</span>, Value:hello world<br></code></pre></td></tr></table></figure>\n\n<p>从上面的输出可看出</p>\n<ul>\n<li>从第 1-3 行输出可见，每个线程通过 ThreadLocal 的 get() 方法拿到的是不同的 StringBuilder 实例</li>\n<li>第 1-3 行输出表明，每个线程所访问到的是同一个 ThreadLocal 变量</li>\n<li>从 7、12、13 行输出以及第 30 行代码可见，虽然从代码上都是对 Counter 类的静态 counter 字段进行 get() 得到 StringBuilder 实例并追加字符串，但是这并不会将所有线程追加的字符串都放进同一个 StringBuilder 中，而是每个线程将字符串追加进各自的 StringBuidler 实例内</li>\n<li>对比第 1 行与第 15 行输出并结合第 38 行代码可知，使用 set(T t) 方法后，ThreadLocal 变量所指向的 StringBuilder 实例被替换</li>\n</ul>\n","text":"Java 相关知识点ArrayList 和 Vector 的区别 这张图里的内容对我们学习 Java 来说，非常的重要，白色的部分是需要去了解的，黄色部分是我们...","permalink":"/post/java/Java面试题收集整理","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"java","slug":"java","count":2,"path":"api/categories/java.json"}],"tags":[{"name":"面试","slug":"面试","count":1,"path":"api/tags/面试.json"},{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9\"><span class=\"toc-text\">Java 相关知识点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">ArrayList 和 Vector 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">HashMap 原理及实现学习总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80-HashMap-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">一. HashMap 的工作原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C-HashMap-%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">二.HashMap 的定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89-HashMap-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">三.HashMap 的数据结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%9B-HashMap-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">四.HashMap 的构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%94-HashMap-%E7%9A%84%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">五.HashMap 的存储实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%AD-%E5%92%8C%E5%85%B6%E4%BB%96-Map-%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">六.和其他 Map 比较</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#HashMap%E3%80%81ConcurrentHashMap%E3%80%81HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">HashMap、ConcurrentHashMap、HashTable 的区别</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#HashMap-%E4%B8%8E-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">HashMap 与 ConcurrentHashMap 的区别</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#ConcurrentHashMap-vs-Hashtable-vs-Synchronized-Map\"><span class=\"toc-text\">ConcurrentHashMap vs Hashtable vs Synchronized Map</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E7%A1%AE%E7%90%86%E8%A7%A3-Thread-Local-%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">正确理解 Thread Local 的原理与适用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ThreadLocal-%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">ThreadLocal 解决什么问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E6%81%B0%E5%BD%93%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">不恰当的理解</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">合理的理解</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ThreadLocal-%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">ThreadLocal 用法</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Gao","slug":"blog-author","avatar":"/img/favicon.ico","link":"/","description":"一些收集总结","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Unity全面屏适配 IOS","uid":"0a640b43ba2e6fd4cef7f6c9ce1c6f16","slug":"unity3d/Unity全面屏适配-IOS","date":"2020-04-27T21:24:45.000Z","updated":"2024-11-16T08:01:11.356Z","comments":true,"path":"api/articles/unity3d/Unity全面屏适配-IOS.json","keywords":null,"cover":null,"text":"Unity 全面屏适配 修改 xcode 方法 123456789101112131415string src = @\" _window = [[UIWindo...","permalink":"/post/unity3d/Unity全面屏适配-IOS","photos":[],"count_time":{"symbolsCount":730,"symbolsTime":"1 mins."},"categories":[{"name":"unity3d","slug":"unity3d","count":1,"path":"api/categories/unity3d.json"}],"tags":[{"name":"ugui","slug":"ugui","count":1,"path":"api/tags/ugui.json"}],"author":{"name":"Gao","slug":"blog-author","avatar":"/img/favicon.ico","link":"/","description":"一些收集总结","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Github","uid":"cc217f8ad2b16d80f09e9b03836cc169","slug":"git/github","date":"2020-04-27T21:06:28.000Z","updated":"2024-11-16T08:01:11.348Z","comments":true,"path":"api/articles/git/github.json","keywords":null,"cover":null,"text":"github Clone 加速 git config –global http.postBuffer 524288000postBuffer(智能 HTTP 传...","permalink":"/post/git/github","photos":[],"count_time":{"symbolsCount":498,"symbolsTime":"1 mins."},"categories":[{"name":"git","slug":"git","count":2,"path":"api/categories/git.json"}],"tags":[{"name":"github","slug":"github","count":1,"path":"api/tags/github.json"}],"author":{"name":"Gao","slug":"blog-author","avatar":"/img/favicon.ico","link":"/","description":"一些收集总结","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}