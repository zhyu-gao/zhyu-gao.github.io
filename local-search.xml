<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cloudflared Tunnel ipv6</title>
    <link href="/2024/12/02/cloudflare/cloudflared%20tunnel/"/>
    <url>/2024/12/02/cloudflare/cloudflared%20tunnel/</url>
    
    <content type="html"><![CDATA[<h1 id="Cloudflared-Tunnel-ipv6"><a href="#Cloudflared-Tunnel-ipv6" class="headerlink" title="Cloudflared Tunnel ipv6"></a>Cloudflared Tunnel ipv6</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> cloudflare/cloudflared:latest tunnel --no-autoupdate <span class="hljs-built_in">run</span> --token eyJhIjoiY2E0…………<br></code></pre></td></tr></table></figure><blockquote><p>修改为</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --dns  <span class="hljs-number">2606</span>:<span class="hljs-number">4700</span>:<span class="hljs-number">4700</span>::<span class="hljs-number">1111</span>   --network host -d cloudflare/cloudflared:latest   tunnel  --edge-ip-version <span class="hljs-number">6</span>    --no-autoupdate run  --token eyJhIjoiY2E0OD……<br></code></pre></td></tr></table></figure><p>主要是要添加 –edge-ip-version 6<br>network host 一定要加上</p>]]></content>
    
    
    <categories>
      
      <category>Cloudflare</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cloudflared</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZeroTier内网穿透</title>
    <link href="/2024/11/11/os/zerotier/"/>
    <url>/2024/11/11/os/zerotier/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-ZeroTier-实现内网穿透"><a href="#使用-ZeroTier-实现内网穿透" class="headerlink" title="使用 ZeroTier 实现内网穿透"></a>使用 ZeroTier 实现内网穿透</h1><h2 id="安装及配置查看其他教程"><a href="#安装及配置查看其他教程" class="headerlink" title="安装及配置查看其他教程"></a>安装及配置查看其他教程</h2><h2 id="如何实现直连"><a href="#如何实现直连" class="headerlink" title="如何实现直连"></a>如何实现直连</h2><ul><li>主要需要开启 ipv6，开启 ipv6 后可以打洞实现直连，提升连接体验，现在大部分运营商都提供了 ipv6</li><li>使用 zerotier 内网穿透不需要开启 ipv6 公网模式，保证安全又可以实现异地组网</li><li>小米路由开启 ipv6，选择 net 模式就行，不要修改光猫</li><li>tplink 有个 ipv6 桥接模式，开启即可</li></ul>]]></content>
    
    
    <categories>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网穿透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强转溢出与浮点数运算</title>
    <link href="/2021/10/09/%E5%BC%BA%E8%BD%AC%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    <url>/2021/10/09/%E5%BC%BA%E8%BD%AC%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="java-中的数据类型转换"><a href="#java-中的数据类型转换" class="headerlink" title="java 中的数据类型转换."></a>java 中的数据类型转换.</h3><p>在 java 中，存在两种转换的机制，默认类型转换（隐式转换）和强制类型转换。默认类型转换的规则如下：</p><ul><li><p>byte，short，char -&gt; int -&gt;long -&gt;float -&gt;double</p></li><li><p>当 byte，short，char 相互之间不能转换，它们参与运算首先将转换成 int 类型进行运算。</p></li></ul><p>强制类型转换：</p><ul><li>目标类型 变量名 &#x3D; (目标类型)(被转换的类型)</li></ul><p>在进行类型转换时：</p><ol><li>容量大的数据类型转换为容量小的数据类型时，要加上强制转换符，但可能造成精度降低或溢出；使用时要格外注意。</li><li>有多种类型的数据混合运算时，系统首先自动的将所有数据转换成容量最大的那一种数据类型，然后再进行计算。</li></ol><p>byte 的存储范围是-128-127 的整数范围，那么如果有如下语句：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">byte a <span class="hljs-operator">=</span> (byte)<span class="hljs-number">130</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>结果会是多少呢？java 是如何处理强制类型转换的溢出处理呢？</p><p>在计算机中，所有的数据都是存储的补码形式，那么 130 首先被当成 int 型存储，四个字节 32 位，它的补码如下：0000 0000 0000 0000 0000 0000 1000 0010，转换为 byte 类型，进行截取，高字节部分去除，保留低字节部分，得到转换为 byte 类型的补码为：1000 0010，我们将其转换为源码：补码（1000 0010）-&gt;反码（1000 0001）-&gt;原码（1111 1110）为-126，所以最后的答案是-126.如果遇到其他的类型转换，也采用类似的处理方法。</p><p>我们都知道 Java 中基本数据类型中，整型的有<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>,依次占用内存空间是<code>1、2、4、8</code>个字节，它们的取值范围如下：</p><table><thead><tr><th>类型</th><th>字节数</th><th>取值范围</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>[-128，127]</td></tr><tr><td>short</td><td>2</td><td>[-32768，32767]</td></tr><tr><td>int</td><td>4</td><td>[-2147483648，2147483647]</td></tr><tr><td>long</td><td>8</td><td>[-9223372036854775808，9223372036854775807]</td></tr></tbody></table><p>既然数据有范围，那么就会存在<code>数据溢出</code>的问题，那么我们看下数据溢出了会是怎样的？</p><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>我们知道，整型数据在计算机中都是用<code>二进制</code>表示的。这里我们继续拿 byte 进行举例，比如说<code>1</code>的二进制表示为<code>0000 0001</code>，<code>-1</code>的二进制表示为<code>1000 0001</code>，最高位是<code>符号位</code>，1 表示负数，0 表示正数。</p><p>我们知道<code>byte</code>类型占一个字节，也就是 8bit，那么它应该能表示 128 个数字；除去最高位的符号位后，还有 7 个 bit 来表示数字，也就是<code>[0,127]</code>这个范围，共 128 个数字；如果加上符号位，那么<code>byte</code>可以表示的数的范围是<code>[-127,-0]</code>和<code>[0,127]</code>，-0 和 0 表示的数据相同，我们进行合并，所以范围应该是<code>[-127,127]</code>，而 java 规定的范围是<code>[-128,127]</code>，<code>-128</code>怎么表示的。</p><p>其实<code>-128</code>就是用<code>-0</code>来表示的，二进制的<code>补码</code>表示就是<code>1000 0000</code>。</p><p>接下来我们说下几个基本概念：原码、反码和补码。</p><h4 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h4><p><code>原码</code>：就是数据的二进制表示形式，最高位是符号位，1 表示负数，0 表示正数。</p><p><code>反码</code>：正数的反码跟原码相同；负数的反码是在原码的基础上，符号位不变，其余各位取反，1 变 0，0 变 1。</p><p><code>补码</code>：正数的补码跟原码相同；负数的补码是在其反码的基础上加 1。</p><p>比如说，<code>10</code>的原码是<code>0000 1010</code>，由于它是正数，所以它的反码和补码均与原码相同。 <code>-10</code>的原码是<code>1000 1010</code>；它的反码是<code>在原码基础上，符号位不变，其余位数取反</code>，转换后的反码是<code>1111 0101</code>；补码是<code>在反码的基础上+1</code>，转换后的补码是<code>1111 0110</code>。</p><h4 id="加法运算过程拆解"><a href="#加法运算过程拆解" class="headerlink" title="加法运算过程拆解"></a>加法运算过程拆解</h4><p>在计算机的二进制计算中，<code>减法运算</code>也会转化为<code>加法运算</code>来计算。</p><p>对于<code>10-10=0</code>的这个运算，在实际计算过程中，会将<code>10 - 10</code>的操作转化为<code>10 + (-10)</code>。接下来我们看下具体的运算过程：</p><table><thead><tr><th>数据类型</th><th>10</th><th>-10</th></tr></thead><tbody><tr><td>原码</td><td><code>0000 1010</code></td><td><code>1000 1010</code></td></tr><tr><td>反码</td><td><code>0000 1010</code></td><td><code>1111 0101</code></td></tr><tr><td>补码</td><td><code>0000 1010</code></td><td><code>1111 0110</code></td></tr></tbody></table><p>得到对应的补码之后，我们对<code>10</code>和<code>-10</code>的补码进行加法操作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">+</span> <span class="hljs-number">0000 </span><span class="hljs-number">1010</span><br><span class="hljs-string">———————————</span> <span class="hljs-string">=</span> <span class="hljs-number">0000 </span><span class="hljs-number">0000</span><br>  <span class="hljs-number">1111 </span><span class="hljs-number">0110</span><br><span class="hljs-string">复制代码</span><br></code></pre></td></tr></table></figure><p>我们知道补码<code>0000 0000</code>对应的原码也为<code>0000 0000</code>，所以可以得出<code>10 - 10 = 0</code>。</p><h4 id="验证-byte-127-1-结果"><a href="#验证-byte-127-1-结果" class="headerlink" title="验证(byte)(127 +1)结果"></a>验证<code>(byte)(127 +1)</code>结果</h4><p>我们接着看下<code>byte</code>类型的<code>127 + 1</code>的运算过程。</p><table><thead><tr><th>数据类型</th><th>127</th><th>1</th></tr></thead><tbody><tr><td>原码</td><td><code>0111 1111</code></td><td><code>0000 0001</code></td></tr><tr><td>反码</td><td><code>0111 1111</code></td><td><code>0000 0001</code></td></tr><tr><td>补码</td><td><code>0111 1111</code></td><td><code>0000 0001</code></td></tr></tbody></table><p>得到对应的补码之后，我们对相应的补码进行加法操作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">+</span> <span class="hljs-number">0111 </span><span class="hljs-number">1111</span><br><span class="hljs-string">———————————</span> <span class="hljs-string">=</span> <span class="hljs-number">1000 </span><span class="hljs-number">0000</span><br>  <span class="hljs-number">0000 </span><span class="hljs-number">0001</span><br><span class="hljs-string">复制代码</span><br></code></pre></td></tr></table></figure><p>这里我们得到了<code>1000 0000</code>这个补码，而这个补码对应的数据就是<code>-128</code>，这是一个特例。</p><p>这里需要注意的是，因为使用以前的<code>-0</code>的补码来表示<code>-128</code>, 所以<code>-128</code>并没有原码和反码表示。(对-128 的补码表示<code>[1000 0000]</code>补算出来的原码是<code>[0000 0000]</code>, 这是不正确的)。</p><p>浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。</p><p>在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。</p><p>举个栗子：</p><p>浮点数<code>0.1</code>在计算机中就无法精确表示，因为十进制的<code>0.1</code>换算成二进制是一个无限循环小数，很显然，无论使用<code>float</code>还是<code>double</code>，都只能存储一个<code>0.1</code>的近似值。但是，<code>0.5</code>这个浮点数又可以精确地表示。</p><p>因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：</p><h1 id="电脑是怎样储存一个整数的-Integer"><a href="#电脑是怎样储存一个整数的-Integer" class="headerlink" title="电脑是怎样储存一个整数的(Integer)"></a>电脑是怎样储存一个整数的(Integer)</h1><p>在讲为什么会存在浮点误差之前，先来谈谈电脑是怎么用 0 跟 1 来表示一个 <strong>整数</strong> 的，大家应该都知道二进制：例如 <code>101</code> 代表 $2^2 + 2^0$ 也就是 5、<code>1010</code> 代表 $2^3 + 2^1$ 也就是 10。</p><p><img src="https://img.formels.top/image/202411061456484.png"></p><p>如果是一个无符号的 32 bit 整数，代表它有 32 个位置可以放 0 或 1，所以最小值就是 <code>0000...0000</code> 也就是 0，而最大值 <code>1111...1111</code> 代表 $2^{31} + 2^{30} + … + 2^1 + 2^0$ 也就是 4294967295</p><p>从排列组合的角度来看，因为每一个 bit 位都可以是 0 或 1，整个变量的值有 $2^{32}$ 种可能，所以可以 <strong>精确的</strong> 表达出 0 到 $2^{23} - 1$ 之间的任一个值，不会有任何误差。</p><h1 id="浮点数-Floating-Point"><a href="#浮点数-Floating-Point" class="headerlink" title="浮点数(Floating Point)"></a>浮点数(Floating Point)</h1><p>虽然从 0 到 $2^{23} - 1$ 之间存在很多个整数，但其数量终究是 <strong>有限</strong> 的，就是 $2^{32}$ 那么多个而已；但浮点数就不同了，我们可以这样想：在 1 到 10 这个区间中只有十个整数，却有 <strong>无穷多个</strong> 浮点数，例如 5.1、5.11、5.111 等等，怎么也列举不完。</p><p>但因为在 32 bit 的空间中就只有 2³² 种可能性，为了把所有浮点数都塞在这个 32 bit 的空间里面，许多 CPU 厂商发明了各种浮点数的表示方式，但如果每家 CPU 的格式都不一样也很麻烦，所以最后是以 <a href="https://link.segmentfault.com/?enc=GMa5PvBh+EdBrhkLW9lknQ==.hq84dRUaWkMUL+vwKQXx/tpvQ3LYbxKo+NmrCclmw8WYclzBVH8rjNOfQ60firg54Rk3usilCMEM/xgn2rWvUVbEtQPP5w4u1nehML7kybet8v0Vnf2lQ4Bd485pohIUHvImE5C6b5BKgTsbrlvt1A==">IEEE</a> 发布的 <a href="https://link.segmentfault.com/?enc=RS87AVeCLnK3VvpawDirEQ==.O/Qc3M8TOzxMVK2nzCpYqlH/hwRX8utjzXdsGsgkqPKArzn8RN2tg6plsoXOhLY5">IEEE 754</a> 作为通用的浮点数运算标准，现在的 CPU 也都遵循这个标准进行设计。</p><h1 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h1><p>IEEE 754 里面定义了很多东西，其中包括单精度（32 bit）、双精度（64 bit）和特殊值（无穷大、NaN）的表示方式等等</p><h2 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h2><p>以 8.5 这个浮点数来说，如果要变成 IEEE 754 格式的话必须先做一些规格化处理：把 8.5 拆成 8 + 0.5 也就是 $2^3 + (\cfrac{1}{2})^1$ ，接着写成二进位变成 <code>1000.1</code>，最后再写成 $1.0001 \times 2^3$，与十进制的科学记数法很相似。</p><h2 id="单精度浮点数"><a href="#单精度浮点数" class="headerlink" title="单精度浮点数"></a>单精度浮点数</h2><p>在 IEEE 754 中 32 bit 浮点数被拆分成三个部分，分别是 数符（sign）、阶码（exponent） 和尾数（fraction），加起来总共是 32 个 bit</p><p><img src="https://img.formels.top/image/202411061456179.png"></p><ul><li>数符（sign）：最左侧的 1 bit 代表正负号，正数的话 sign 就为 0，反之则是 1</li><li>阶码（exponent）：中间的 8 bit 代表规格化之后的次方数，采用的是 <strong>阶码真值 +127</strong> 的格式，也就是 3 还要再加上 127 等于 130</li><li>尾数（fraction）：最右侧的 23 bit 放的是小数部分，以 <code>1.0001</code> 来说就是去掉 <code>1.</code> 之后的 <code>0001</code></li></ul><p>所以如果把 8.5 表示成 32 bit 格式的话应该是这样：</p><p><img src="https://img.formels.top/image/202411061456454.png"></p><h2 id="什么情况下会产生误差？"><a href="#什么情况下会产生误差？" class="headerlink" title="什么情况下会产生误差？"></a>什么情况下会产生误差？</h2><p>前面举的 8.5 的例子可以表示为 $2^3 + (\cfrac{1}{2})^1$ ，是因为 8 和 0.5 刚好都是 2 的次方数，所以完全不会产生任何精准度问题。</p><p>但如果是 8.9 的话因为没办法换成 2 的次方数相加，所以最后会被迫表示成 $1.0001110011… \times 2^3$，而且还会产生大概 $0.0000003$ 的误差，如果对结果好奇的话可以到 <a href="https://link.segmentfault.com/?enc=xXrFiGGqitQzX0jigVJ7pw==.6AjLqmqz2hu6uz0S5NIq/eTX2VwObRQ+CU3IXxL1cYMRiLLoU75yPghNyJFMXA6SFv/zvwV6nMscwzMp7ZnYlQ==">IEEE-754 Floating Point Converter</a> 网站上玩玩看。</p><h2 id="双精度浮点数"><a href="#双精度浮点数" class="headerlink" title="双精度浮点数"></a>双精度浮点数</h2><p>前面所讲的单精度浮点数只用了 32 bit 来表示，为了让误差更小，IEEE 754 也定义了如何用 64 bit 来表示浮点数，跟 32 bit 比起来 fraction 部分扩大了两倍多，从 23 bit 变成 52 bit，所以精准度自然会提高许多。</p><p><img src="https://img.formels.top/image/202411061457992.png"></p><p>以刚才的 8.9 为例，用 64 bit 表示的话虽然可以变得更准，但因为 8.9 无法完全写成 2 的次方数相加，到了小数下 16 位仍然会出现误差，不过与单精度的误差 0.0000003 比起来已经小了很多</p><p><img src="https://img.formels.top/image/202411061457357.png"></p><p>类似的情况还有像 Python 中的 <code>1.0</code> 跟 <code>0.999...999</code> 是相等的、<code>123</code> 跟 <code>122.999...999</code> 也是相等的，因为他们之间的差距已经小到无法放在 fraction 里面，所以从二进制格式看来它们每一个二进制位都是一样的。</p><p><img src="https://img.formels.top/image/202411061457391.png"></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>既然浮点数的误差是无法避免的，那就只好跟它共处了，下面是两个比较常见的处理方法：</p><h2 id="设定最大允许误差-ε-epsilon"><a href="#设定最大允许误差-ε-epsilon" class="headerlink" title="设定最大允许误差 ε (epsilon)"></a>设定最大允许误差 ε (epsilon)</h2><p>在某些语言会提供所谓的 epsilon，用来让你判断是不是在浮点误差的允许范围内，以 Python 来说 epsilon 的值大约是 $2.2e^{-16}$</p><p><img src="https://img.formels.top/image/202411061457460.png"></p><p>所以你可以把 <code>0.1 + 0.2 == 0.3</code> 改写成 <code>0.1 + 0.2 — 0.3 &lt;= epsilon</code>，这样就能避免浮点误差在运算过程中捣乱，正确的比较出 0.1 加 0.2 是不是等于 0.3 了。</p><blockquote><p>当然如果系统没提供的话你也可以自己定义一个 epsilon，设定在 2 的 -15 次方左右</p></blockquote><h2 id="完全使用十进制进行计算"><a href="#完全使用十进制进行计算" class="headerlink" title="完全使用十进制进行计算"></a>完全使用十进制进行计算</h2><p>之所以会有浮点误差，是因为把十进制转为二进制的过程中没办法把所有的小数部分都塞进了尾数中，既然转换可能会有误差，那干脆就不转了，直接用十进制来做运算。</p><p>在 Python 里面有一个 module 叫做 <a href="https://link.segmentfault.com/?enc=EGqzPiHvOGHU5YymrWlxKw==.8AEYfFMlIGJ/8spbR0ywxxV+rdFNfmvm+jodZzcUm5k5eBGb05+GlQKMii02WfXa+8pfz2yV6OoysUDEWJz5WA==">decimal</a>，在 JavaScript 中也有类似的包。它可以帮你用十进制来进行计算，就像你自己用纸笔计算 0.1 + 0.2 绝对不会出错、也不会有任何误差。</p><p><img src="https://img.formels.top/image/202411061458514.png"></p><p>虽然用十进制进行计算可以完全避免浮点数的误差，但因为 Decimal 的十进制计算是模拟出来的，在最底层的 CPU 电路中还是在用二进制进行运算，执行起来会比原生的浮点运算慢很多，所以不建议所有的浮点运算都用 Decimal 来进行。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑苹果优化</title>
    <link href="/2021/08/31/hackintosh/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%BC%98%E5%8C%96/"/>
    <url>/2021/08/31/hackintosh/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="黑果优化"><a href="#黑果优化" class="headerlink" title="黑果优化"></a>黑果优化</h2><ol><li>命令调试检查</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 检查 XCPM 是否正常加载，返回 1为正常</span><br><span class="hljs-variable">$ </span>sysctl machdep.xcpm.mode<br><span class="hljs-comment"># 验证 X86PlatformPlugin.kext 是否已经加载</span><br><span class="hljs-variable">$ </span>kextstat|grep -y x86plat<br><span class="hljs-comment"># 验证 Apple Intel CPU 电源管理，返回为空表示正常</span><br><span class="hljs-variable">$ </span>kextstat|grep -y appleintelcpu<br><span class="hljs-comment"># 验证是否加载变频，返回 1 为正常</span><br><span class="hljs-variable">$ </span>sysctl -n machdep.xcpm.vectors_loaded_count<br></code></pre></td></tr></table></figure><ol start="2"><li>Mac 升级后配置上的小红点去掉方法</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 在终端执行下面命令：</span><br><span class="hljs-variable">$</span> defaults <span class="hljs-built_in">write</span> com.apple.systempreferences AttentionPrefBundleIDs <span class="hljs-number">0</span><br><span class="hljs-variable">$</span> killall Dock<br></code></pre></td></tr></table></figure><ol start="3"><li>禁止系统更新提示代码命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> softwareupdate --ignore “macOS Catalina”</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">放弃更改，使用下面进行重置</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> softwareupdate --reset-ignored</span><br></code></pre></td></tr></table></figure><ol start="4"><li>安装任何来源软件</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo spctl --master-<span class="hljs-built_in">disable</span><br><span class="hljs-comment"># 可选：关闭sip，即System Integrity Protection系统完整保护，将一些文件目录和系统应用保护了起来</span><br>$ csrutil <span class="hljs-built_in">disable</span><br><span class="hljs-comment"># 查看关闭状态</span><br>csrutil status<br></code></pre></td></tr></table></figure><ol start="5"><li>本 Mac 和 Win 系统的时间不同步问题及解决方法：</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># win系统里，请在管理员cmd运行命令如下：</span><br>Reg <span class="hljs-keyword">add</span><span class="language-bash"> HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1</span><br></code></pre></td></tr></table></figure><ol start="6"><li>安装 Mac os 后“其他宗卷”占用大量空间，这个问题通常是 Mac 的“safe sleep”功能开启导致的，关闭方法如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在终端中输入下面的命令</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> pmset -a hibernatemode 0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后定位到/private/var/vm/删除已经存在的sleepimage文件</span><br></code></pre></td></tr></table></figure><ol start="7"><li>升级 10.15 后，开启 hidpi 用之前的脚本方式无法开启，新系统 system&#x2F;library 变成了只读，脚本文件无法写入，解锁方式：</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo <span class="hljs-built_in">mount</span> <span class="hljs-literal">-uw</span> /<br><span class="hljs-variable">$</span> killall Finder<br></code></pre></td></tr></table></figure><ol start="8"><li>Kext Utility 了解，由于 macOS 10.15 锁住了 S&#x2F;L&#x2F;E 的修改权限，因此在修改 kext 前要使用终端先解锁 System&#x2F;Library&#x2F;Extensions 权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打开终端依次输入</span><br>$ <span class="hljs-built_in">sudo</span> su<br>$ <span class="hljs-built_in">sudo</span> mount -uw /<br>$ killall Finder<br><span class="hljs-comment"># 重建缓存</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">touch</span> /System/Library/Extensions &amp;&amp; <span class="hljs-built_in">sudo</span> kextcache -u<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hackintosh</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hackintosh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML元素间距问题</title>
    <link href="/2021/08/11/html/HTML%E5%85%83%E7%B4%A0%E9%97%B4%E8%B7%9D%E9%97%AE%E9%A2%98/"/>
    <url>/2021/08/11/html/HTML%E5%85%83%E7%B4%A0%E9%97%B4%E8%B7%9D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML-元素间距问题"><a href="#HTML-元素间距问题" class="headerlink" title="HTML 元素间距问题"></a>HTML 元素间距问题</h2><p>在利用 CSS 布局时，经常会遇到一些没有定义间距 padding、margin 之类的内容，但是页面上却总会有一些不知从何而来的间距出现，下面就是我在自己的工作中遇到的一些常见情况的总结，及其消除方法。</p><ol><li><p>并排 div 之间的间距。<br>a. 多个 div 元素在定义属性：display:inline-block;后，多个 div 元素之间并排排列，但是它们之间总是隔着那么几像素的距离，即便你一次又一次修改自己的 padding、margin 设置为 0，都没办法取消。</p><p>b. 它们之间存在的间距，是因为不同 div 之间存在默认间距，因为写代码的习惯，一个 div 元素结束之后，我们总会换行开始写代码，这一换行就是 div 之间存在间距的原因。</p><p>所以解决办法很简单，a.去掉代码上不同 div 元素之间的换行或者空格即可，这个方法在代码可读性上有些不可取。如果你对代码格式有很严格的限制，像我一样是个无可救药的强迫症，你就选择下面的方法吧。b.利用注释将 div 之间的空格标记起来。c.网上还有人提到过一种解决方案，将 margin 设置为负值，这个方法也是可行的，但是由于浏览器之间的标准差异，margin 的设置可能会需要在不同浏览器中设置为不同的值，增加了工作的复杂度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;color-choice&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>this is div 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">     --&gt;</span>&lt;divclass=&quot;color-choice&quot;&gt;<br>       <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>this is div 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">     --&gt;</span>&lt;divclass=&quot;color-choice&quot;&gt;<br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>this is div 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>问题归纳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux添加Service</title>
    <link href="/2021/05/10/linux/Linux%E6%B7%BB%E5%8A%A0Service/"/>
    <url>/2021/05/10/linux/Linux%E6%B7%BB%E5%8A%A0Service/</url>
    
    <content type="html"><![CDATA[<h3 id="Linux-添加-Service-实现自启动"><a href="#Linux-添加-Service-实现自启动" class="headerlink" title="Linux 添加 Service 实现自启动"></a>Linux 添加 Service 实现自启动</h3><blockquote><p>以启动 jar 包为例</p></blockquote><ol><li>cd &#x2F;ets&#x2F;systemd&#x2F;system</li><li>创建自己的 service 文件</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhyu-gao/zhyu-gao.github.io@image/uPic/image-20210510161902086.png" alt="image-20210510161902086"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=yourProjectName #描述<br>After=syslog.target network.target #依赖<br><br>[Service]<br>Type=simple<br><br>ExecStart=/usr/bin/java -jar /opt/javaapps/yourProjectName.jar<br><span class="hljs-meta prompt_">#</span><span class="language-bash">前面是java命令的绝对路径 后面是jar包的绝对路径</span><br>ExecStop=/bin/kill -15 $MAINPID<br><br>User=root<br>Group=root<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux安装docker</title>
    <link href="/2021/04/21/linux/Linux%E5%AE%89%E8%A3%85docker/"/>
    <url>/2021/04/21/linux/Linux%E5%AE%89%E8%A3%85docker/</url>
    
    <content type="html"><![CDATA[<h3 id="Centos-安装最新稳定版-docker-方法"><a href="#Centos-安装最新稳定版-docker-方法" class="headerlink" title="Centos 安装最新稳定版 docker 方法"></a>Centos 安装最新稳定版 docker 方法</h3><blockquote><p>脚本安装</p></blockquote><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">curl</span> -<span class="hljs-string">fsSL</span> <span class="hljs-string">get</span>.<span class="hljs-string">docker</span>.<span class="hljs-string">com</span> -<span class="hljs-string">o</span> <span class="hljs-built_in">get-docker.sh</span><br><span class="hljs-string">sh</span> <span class="hljs-built_in">get-docker.sh</span> <span class="hljs-built_in">--mirror</span> <span class="hljs-string">Aliyun</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring整合WebSocket</title>
    <link href="/2021/03/27/java/Spring%E6%95%B4%E5%90%88WebSocket/"/>
    <url>/2021/03/27/java/Spring%E6%95%B4%E5%90%88WebSocket/</url>
    
    <content type="html"><![CDATA[<h3 id="Spring-整合-websocket-设置"><a href="#Spring-整合-websocket-设置" class="headerlink" title="Spring 整合 websocket 设置"></a>Spring 整合 websocket 设置</h3><blockquote><p>Maven 添加 Jar 包</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring websocket --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-messaging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- websocket end --&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>Spring xml 配置方式</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- websocket 配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">websocket:message-broker</span> <span class="hljs-attr">application-destination-prefix</span>=<span class="hljs-string">&quot;/app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">websocket:stomp-endpoint</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/websocket&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">websocket:sockjs</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">websocket:stomp-endpoint</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">websocket:simple-broker</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;/topic&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">websocket:client-inbound-channel</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">websocket:interceptors</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;net.example.projects.web.WebSocketInterceptor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">websocket:interceptors</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">websocket:client-inbound-channel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">websocket:message-broker</span>&gt;</span><br><span class="hljs-comment">&lt;!-- websocket end --&gt;</span><br></code></pre></td></tr></table></figure><p>此处启用 stomp</p><p><code>STOMP</code> 中文为: 面向消息的简单文本协议</p><p><code>websocket</code>定义了两种传输信息类型:<strong>文本信息和二进制信息</strong>。类型虽然被确定，但是他们的传输体是没有规定的。所以，需要用一种简单的文本传输类型来规定传输内容，它可以作为通讯中的文本传输协议。</p><p>STOMP 是基于帧的协议，客户端和服务器使用 STOMP 帧流通讯</p><p>一个 STOMP 客户端是一个可以以两种模式运行的用户代理，可能是同时运行两种模式。</p><ul><li>作为生产者，通过<code>SEND</code>框架将消息发送给服务器的某个服务</li><li>作为消费者，通过<code>SUBSCRIBE</code>制定一个目标服务，通过<code>MESSAGE</code>框架，从服务器接收消息。</li></ul><p>基于 websocket 的一层 STOMP 封装，让业务端只需关心数据本身，不需要太过关心文本协议。当然还是需要了解一些 STOMP 协议各个 Frame 的概念和应用场景。</p><blockquote><p>拦截器配置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInterceptorAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123;<br>        <span class="hljs-type">StompHeaderAccessor</span> <span class="hljs-variable">accessor</span> <span class="hljs-operator">=</span> MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);<br>        <span class="hljs-comment">//1、判断是否首次连接</span><br>        <span class="hljs-keyword">if</span> (StompCommand.CONNECT.equals(accessor.getCommand())) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> accessor.getNativeHeader(<span class="hljs-string">&quot;userId&quot;</span>).get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> userId;<br>            <span class="hljs-type">Principal</span> <span class="hljs-variable">principal</span> <span class="hljs-operator">=</span> () -&gt; name;<br>            WebSocketManager.connect(name);<br>            accessor.setUser(principal);<br>            <span class="hljs-keyword">return</span> message;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (StompCommand.DISCONNECT.equals(accessor.getCommand())) &#123;<br>            <span class="hljs-type">Principal</span> <span class="hljs-variable">principal</span> <span class="hljs-operator">=</span> accessor.getUser();<br>            WebSocketManager.disconnect(principal.getName());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截处理连接和断开操作，Principal 设置连接的用户，之后就可以发送消息到指定用户。</p><h3 id="常用-Command"><a href="#常用-Command" class="headerlink" title="常用 Command"></a>常用 Command</h3><ul><li>CONNECT</li><li>CONNECTED</li><li>SEND</li><li>SUBSRIBE</li><li>UNSUBSRIBE</li><li>BEGIN</li><li>COMMIT</li><li>ABORT</li><li>ACK</li><li>NACK</li><li>DISCONNECT</li></ul><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>服务器可以通过<code>@MessageMapping</code>方法处理请求</p><p><code>SendToUser(&quot;/topic/websocket&quot;)</code>发送消息</p><p>需要强调的是 web.xml 中的路径匹配问题 写为<url-pattern>&#x2F;</url-pattern>全部匹配的</p><p>如果使用路径匹配<url-pattern>&#x2F;wsk&#x2F;*</url-pattern></p><p>spring 中的地址不能写为&lt;websocket:mapping path&#x3D;”&#x2F;wsk&#x2F;echo” 只需要写为 &lt;websocket:mapping path&#x3D;”&#x2F;echo”就可以了,不然无法访问,这个是很多人都会遇到的坑.需特别注意</p><h3 id="手动管理-WebSocketSession"><a href="#手动管理-WebSocketSession" class="headerlink" title="手动管理 WebSocketSession"></a>手动管理 WebSocketSession</h3><p>配置时添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">websocket:transport</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">websocket:decorator-factories</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;net.example.web.CustomWebSocketHandlerDecorator&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">websocket:decorator-factories</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">websocket:transport</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加代码</p><p><img src="https://cdn.jsdelivr.net/gh/zhyu-gao/zhyu-gao.github.io@image/uPic/carbon.png" alt="carbon"></p><p>将 WebSocketSession 保存，留作后续处理</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Somenote</title>
    <link href="/2021/02/19/java/somenote/"/>
    <url>/2021/02/19/java/somenote/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Java-中-new-Date-long-date"><a href="#1-Java-中-new-Date-long-date" class="headerlink" title="1. Java 中 new Date(long date)"></a>1. Java 中 new Date(long date)</h3><p>如果是 10 位时间戳,就是秒级别的转成 date 是有问题的,成格林尼治时间<br>需要用毫秒级的,就是 13 的时间戳才能得到正确的时间</p><h3 id="2-html-中的-disable"><a href="#2-html-中的-disable" class="headerlink" title="2. html 中的 disable"></a>2. html 中的 disable</h3><blockquote><p>html 中的标签添加 disable 属性后不会将属性发送到后台,readonly 可以,但是 select 标签是没有 readonly 属性,所以需要用其他方法解决.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Resume</title>
    <link href="/2020/07/28/resume/"/>
    <url>/2020/07/28/resume/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>resume</category>
      
    </categories>
    
    
    <tags>
      
      <tag>resume</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 JVM 之 垃圾回收机制</title>
    <link href="/2020/04/28/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JVM-%E4%B9%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/04/28/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JVM-%E4%B9%8B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://juejin.im/post/5c73c7c96fb9a049dd80eedb">https://juejin.im/post/5c73c7c96fb9a049dd80eedb</a></p><h1 id="深入理解-JVM-之-垃圾回收机制"><a href="#深入理解-JVM-之-垃圾回收机制" class="headerlink" title="深入理解 JVM 之 垃圾回收机制"></a>深入理解 JVM 之 垃圾回收机制</h1><p>虽然内存的分配和回收技术已相当成熟，但如果需要排查内存溢出、内存泄露问题，或者要求高并发、高性能时，就需要对垃圾的回收进行监控和调节，以更好优化系统提高性能。</p><h2 id="对象存活判定"><a href="#对象存活判定" class="headerlink" title="对象存活判定"></a>对象存活判定</h2><p><code>Java</code> 内存结构中，程序计数器、虚拟机栈、本地方法栈等随着线程而生，随线程而灭，不需要考虑内存回收问题。而 <code>Java</code> 堆和方法区则不同，它们的内存分配是动态的，只有在运行期间才能知道会创建哪些对象，垃圾回收关注的就是这两部分。</p><p>垃圾回收首先需要判断哪些对象还存活着，主要有引用计数和可达性分析两种算法。</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>它的原理如下：给对象添加一个引用计数器，每当有一个地方引用它时，计时器值就加 <code>1</code>；当引用失效时，计数器值就减 <code>1</code>；如果计数器为 0，对象就不可能再被使用。</p><p>引用计数算法虽然实现简单、判定效率较高。但它很难解决对象之间循环引用的问题。</p><p>例如两个对象相互引用，实际上两个对象都不会再访问，但因为相互引用着对方，导致它们的计数器值都不为 <code>0</code>，于是引用技术算法无法通过 <code>GC</code> 收集器回收它们。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>它的原理如下：通过一系列称为 <code>GC Roots</code> 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 <code>GC Roots</code> 没有任何引用链相连时，则证明对象是不可用的。</p><p><code>Java</code> 中，可作为 <code>GC Roots</code> 的对象包括如下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中 <code>JNI</code>( <code>Native</code> 方法) 引用的对象。</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>可以看到，对象回收判定算法判断对象是否存活都与引用有关。从 <code>JDK1.2</code> 开始，引用分为四种类型，用来实现不同的功能，它们的引用强度也依次递减。</p><p><strong>强引用（Strong Reference）</strong></p><p>平时使用的引用就是强引用。只要强引用还存在，该对象永远不会被回收。</p><p>可以通过将对象设置为 <code>null</code>，使其被回收。</p><p><strong>软引用（Soft Reference）</strong></p><p>用于描述一些还有用但并非必需的对象。当系统内存空间不足时，会回收这些软引用指向的对象。它通过 <code>SoftReference</code> 类来实现软引用。</p><p>可以用来实现高速缓存。</p><p><strong>弱引用（Weak Reference）</strong></p><p>用来描绘非必需对象。被弱引用指向的对象只能生存到下一次垃圾回收之前。只要垃圾收集器运行，弱引用指向的对象就会被回收。它通过 <code>WeakReference</code> 类来实现弱引用。</p><p><strong>虚引用（Phantom Reference）</strong></p><p>虚引用和没有引用没有任何区别。一个对象是否有虚引用，不会影响其生存时间，也无法通过虚引用获取对象实例。它通过 <code>PhantomReference</code> 来实现虚引用。必须和引用队列 <code>ReferenceQueue</code> 联合使用。</p><p>为一个对象设置虚引用的唯一目的是该对象被垃圾收集器回收前会收到一条系统通知。</p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区，或者说 <code>HotSpot</code> 虚拟机中的永久代，进行垃圾回收的效率一般比较低。回收主要包括两部分内容：废弃常量和无用的类。</p><p>判断一个常量是否是废弃常量比较简单，与回收 <code>Java</code> 堆中的对象类似。而判定一个类是否是无用的类需要满足三个条件：</p><ul><li>该类所有的实例都已经被回收；</li><li>加载该类的 <code>ClassLoader</code> 已经被回收；</li><li>该类对象的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><p>标记-清除算法分为两个标记和清除阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记过程也就是对象存活判定算法。</p><p><img src="/images/java/jvm/%E4%B8%8B%E8%BD%BD.jpeg" alt="img"></p><p>它是最基础的收集算法，主要有两个缺点：</p><ul><li>效率问题：标记和清除两个过程的效率都不高。</li><li>空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>复制算法将可用内存分为大小相等的两块，每次只使用其中的一块。在一块内存用完后，将仍存活的对象赋值到另一块上面，再把已使用过的内存一次清理掉。</p><p><img src="/images/java/jvm/%E4%B8%8B%E8%BD%BD1.jpeg" alt="img"></p><p>复制算法的优缺点如下：</p><ul><li>优点：每次对半个分区进行内存回收，内存分配时也不用考虑内存碎片等情况，实现简单，运行高效。</li><li>缺点：可使用的内存缩小为一半，代价较大。</li></ul><h3 id="标记-整理算法（Mark-compact）"><a href="#标记-整理算法（Mark-compact）" class="headerlink" title="标记-整理算法（Mark-compact）"></a>标记-整理算法（Mark-compact）</h3><p>标记-整理算法分为标记和整理两个阶段，标记阶段和“标记-清除算法”一样，但在整理阶段，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="/images/java/jvm/%E4%B8%8B%E8%BD%BD2.jpeg" alt="img"></p><p>标记-整理算法的优缺点如下：</p><ul><li>避免了空间碎片，空间利用率较高。</li><li>效率不高，标记和清除过程的效率较低。</li></ul><h3 id="分代算法（Generational-Collection）"><a href="#分代算法（Generational-Collection）" class="headerlink" title="分代算法（Generational Collection）"></a>分代算法（Generational Collection）</h3><p>分代算法根据对象存活周期将内存划分为几块。一般是将 <code>Java</code> 对分为新生代和老年代，根据各个年代的特点采用适当的收集算法。</p><p>新生代中，每次垃圾收集时只有少量对象存活，选择复制算法；老年代中，对象存活率较高、没有额外空间进行分配，使用“标记-清理”或“标记-整理”算法。</p><p>为了对不同生命周期的对象采用不同的回收算法，所以垃圾收集器都采用分代收集算法，将堆分为新生代和老年代。</p><p><img src="https://user-gold-cdn.xitu.io/2019/2/25/1692444b2c55f1f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新生代主要用来存放新创建的对象，一般占堆 <code>1/3</code> 的空间。由于很多对象生命周期很短，每次 <code>Minor GC</code> 后只有少量对象存活，所以选用复制算法。</p><p>新生代又被分为一块较大的 <code>Eden</code> 区和两块较小的大小相等的 <code>Survivor</code> 区，使用 <code>from</code> 和 <code>to</code>来分别指代两个 <code>Survivor</code> 区。<code>HotSpot</code> 虚拟机默认 <code>Eden</code> 和两块 <code>Survivor</code> 的大小比例为 <code>8:1:1</code>。每次只会使用 <code>Eden</code> 和其中一块 <code>Survivor</code> 区为对象服务，所以总是有一块 <code>Survivor</code>区是空闲的，新生代实际可用的内存空间也就为 <code>90%</code>。</p><p>通常，对象会分配在 <code>Eden</code> 区中，当 <code>Eden</code> 区无法在分配对象时，<code>JVM</code> 便会触发一次 <code>Minor GC</code>，将存活下来的对象复制到 <code>from</code> 指向的 <code>Survivor</code> 区中。</p><p>当 <code>from</code> 指向的 <code>Survivor</code> 区也无法分配时，对 <code>Eden</code> 和 <code>from</code> 指向的 <code>Survivor</code> 区执行 <code>Minor GC</code>，将存活下来的对象复制到 <code>to</code> 指向的 <code>Survivor</code> 区中，然后交换 <code>from</code> 和 <code>to</code> 指针，使 <code>to</code>指向的 <code>Survivor</code> 区为空，以保证下次 <code>Minor GC</code> 有复制的空闲空间。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代用于存放大对象，或年龄超过一定程度的对象。一般占据堆 <code>2/3</code> 的空间。</p><p>如果对象需要大量连续的内存空间，例如很长的字符串及数组，这些对象会直接分配在老年代，以避免在 <code>Eden</code> 区及两个 <code>Survivor</code> 区之间发生大量的内存复制。</p><p>虚拟机为每个对象定义了一个对象年龄计数器，如果对象分配在 <code>Eden</code> 区，在经过一次 <code>Minor GC</code>后仍然存活，之后移动到 <code>Survivor</code> 空间中，将其年龄设置为 <code>1</code>。对象在 <code>Survivor</code> 区中每经过一次 <code>Minor GC</code>，年龄就增加一次，当它的年龄增加到一定程度（默认为 <code>15</code>）时，也会被晋升到老年代中。</p><p>如果在 <code>Survivor</code> 区中相同年龄所有对象大小的总和大于 <code>Survivor</code> 区的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p>老年代的对象一般都比较稳定，<code>Major GC</code> 不会频繁执行。<code>Major GC</code> 采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。<code>MajorGC</code> 的耗时较长，而且会产生内存碎片。</p><h3 id="三种清理方式"><a href="#三种清理方式" class="headerlink" title="三种清理方式"></a>三种清理方式</h3><p><strong>Minor GC(Young GC)</strong></p><p>指发生在新生代的垃圾收集动作。当 <code>Eden</code> 区没有足够的空间分配时，就会触发一次 <code>Minor GC</code>。由于 <code>Java</code> 对象大多生命周期较短，所以 <code>Minor GC</code> 非常频繁，一般回收速度也比较快。</p><p><strong>Major GC</strong></p><p>指发生在老年代的垃圾收集动作，在进行 <code>Major GC</code> 前，一般都会进行至少一次 <code>Minor GC</code>。<code>Major GC</code> 的速度一般会比 <code>Minor GC</code> 慢 <code>10</code> 倍以上。</p><p><strong>Full GC</strong></p><p>指回收整个新生代和老年代的垃圾收集动作。成本较高，对系统性能产生影响。<code>FULL GC</code> 的时候会 <code>STOP THE WORD</code>。</p><p>它的触发条件主要有：</p><ul><li>在执行 <code>Minor GC</code> 之前，如果老年代最大可用的连续空间小于历次晋升到老生代对象的平均大小，则触发一次 <code>Full GC</code> 。</li><li>大对象直接进入老年代，或从年轻代晋升上来的老对象，在老年代尝试分配内存，但老年代内存空间不够时。</li><li>显式调用 <code>System.gc()</code> 方法时。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wsl</title>
    <link href="/2020/04/28/os/wsl/"/>
    <url>/2020/04/28/os/wsl/</url>
    
    <content type="html"><![CDATA[<h2 id="创建启动脚本"><a href="#创建启动脚本" class="headerlink" title="创建启动脚本"></a>创建启动脚本</h2><blockquote><p>进入任意 WSL 发行版本中,创建并编辑文件: &#x2F;etc&#x2F;init.wsl</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/sh</span><br>/etc/init.d/cron <span class="hljs-variable">$1</span><br>/etc/init.d/ssh <span class="hljs-variable">$1</span><br>/etc/init.d/supervisor <span class="hljs-variable">$1</span><br></code></pre></td></tr></table></figure><p>里面调用我们希望启动的 3 个服务启动脚本,设置权限,所有者为 root,然后通过</p><blockquote><p>sudo &#x2F;etc&#x2F;init.wsl [start|stop|restart]</p></blockquote><p>来启动我们的服务,在 Windows 中,开始-运行输入:</p><blockquote><p>shell:startup</p></blockquote><p>按照 WSL 使用的 Linux 发行版本启动脚本,如 Ubuntu18.04,创建 ubuntu18.04.vbs:</p><figure class="highlight vbs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbs"><span class="hljs-keyword">Set</span> ws = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;Wscript.Shell&quot;</span>)<br>ws.run <span class="hljs-string">&quot;wsl -d Ubuntu-18.04 -u root /etc/init.wsl start&quot;</span>, vbhide<br></code></pre></td></tr></table></figure><p>如果不知道什么版本可以用 wsl -l 来查看.</p><p>WSL 中有很多其他服务,按需修改&#x2F;etc&#x2F;init.wsl 就可以了.</p>]]></content>
    
    
    <categories>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wsl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows Scoop</title>
    <link href="/2020/04/28/os/windows-scoop/"/>
    <url>/2020/04/28/os/windows-scoop/</url>
    
    <content type="html"><![CDATA[<h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://scoop.sh/">https://scoop.sh</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>自定义 scoop 包安装路径运行下方三行代码</p></blockquote><ul><li><blockquote><p>$env:SCOOP&#x3D;’F:\scoop’</p></blockquote></li><li><blockquote><p>“[environment]::setEnvironmentVariable(‘SCOOP’,$env:SCOOP,’User’)”</p></blockquote></li><li><blockquote><p>iex (new-object net.webclient).downloadstring(‘<a href="https://get.scoop.sh/">https://get.scoop.sh</a>‘)</p></blockquote></li></ul><h3 id="常用软件列表"><a href="#常用软件列表" class="headerlink" title="常用软件列表"></a>常用软件列表</h3><ol><li>7zip：scoop install 7zip</li><li>aria2 引擎：scoop install aria2</li><li>chrome：scoop install chrome</li><li>firefox：scoop install firefox</li><li>opera：scoop install opera</li><li>vivaldi：scoop install vivaldi</li><li>git：scoop install git</li><li>python：scoop install python</li><li>vscode：scoop install vscode</li><li>sublime-text：scoop install sublime-text</li><li>notepadplusplus：scoop install notepadplusplus</li><li>telegram：scoop install telegram</li><li>typora：scoop install typora</li></ol><h3 id="Bucket-软件源"><a href="#Bucket-软件源" class="headerlink" title="Bucket 软件源"></a>Bucket 软件源</h3><p>由于 scoop 比较小众，软件相比 chocolatey 较少<br>不过 scoop 有一个强大的 bucket 软件源策略，而且有社区来维护<br>常用软件基本能够找到</p><p>社区地址：<br><a href="https://github.com/rasa/scoop-directory/blob/master/by-score.md">https://github.com/rasa/scoop-directory/blob/master/by-score.md</a><br>bucket 语法：scoop bucket add [软件源名字(随意)] [源地址]</p><p>bucket 源推荐：</p><p>官方：<br>scoop bucket add main<br>scoop bucket add extras<br>scoop bucket add versions<br>scoop bucket add nightlies<br>scoop bucket add nirsoft<br>scoop bucket add php<br>scoop bucket add nerd-fonts<br>scoop bucket add nonportable<br>scoop bucket add java<br>scoop bucket add games<br>scoop bucket add jetbrains</p><p>国内常用软件：<br>微信、QQ、钉钉……<br>scoop bucket add dorado <a href="https://github.com/h404bi/dorado">https://github.com/h404bi/dorado</a></p><p>小新 Bucket：<br>FSCapture、Shadowsocksrr、UninstallTool、Notepad3、Wechat……<br>scoop bucket add dajiu <a href="https://github.com/dajiiu/dajiu-scoop">https://github.com/dajiiu/dajiu-scoop</a></p><p>其他：<br>scoop bucket add dodorz <a href="https://github.com/dodorz/scoop-bucket">https://github.com/dodorz/scoop-bucket</a></p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><blockquote><p>在安装过程中如果意外终止是没办法继续安装的<br>需要 uninstall 一下然后才能重新安装</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity全面屏适配 IOS</title>
    <link href="/2020/04/28/unity3d/Unity%E5%85%A8%E9%9D%A2%E5%B1%8F%E9%80%82%E9%85%8D-IOS/"/>
    <url>/2020/04/28/unity3d/Unity%E5%85%A8%E9%9D%A2%E5%B1%8F%E9%80%82%E9%85%8D-IOS/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity-全面屏适配"><a href="#Unity-全面屏适配" class="headerlink" title="Unity 全面屏适配"></a>Unity 全面屏适配</h2><ul><li>修改 xcode 方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">string src = @&quot;    _window         = [[UIWindow alloc] initWithFrame: [UIScreen mainScreen].bounds];&quot;;<br><br>string dst = @&quot;//    _window         = [[UIWindow alloc] initWithFrame: [UIScreen mainScreen].bounds];<br><br>  CGRect winSize = [UIScreen mainScreen].bounds;<br>  if (winSize.size.width / winSize.size.height &gt; 2) &#123;<br>      winSize.size.width -= 64;<br>      winSize.origin.x = 32;<br>  &#125;<br>  _window = [[UIWindow alloc] initWithFrame: winSize];<br><br>  &quot;;<br>       string unityAppControllerPath = path + &quot;/Classes/UnityAppController.mm&quot;;<br>       XClassExt UnityAppController = new XClassExt (unityAppControllerPath);<br>       UnityAppController.Replace (src, dst);<br></code></pre></td></tr></table></figure><ul><li>修改 UGUI 方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>unity3d</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ugui</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面试题收集整理</title>
    <link href="/2020/04/28/java/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    <url>/2020/04/28/java/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-相关知识点"><a href="#Java-相关知识点" class="headerlink" title="Java 相关知识点"></a>Java 相关知识点</h1><h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h3><p><img src="/images/util.png" alt="Util常用类"></p><p>这张图里的内容对我们学习 Java 来说，非常的重要，白色的部分是需要去了解的，黄色部分是我们要去重点了解的，不但要知道怎么去用，至少还需要读一次源码。绿色部分内容已经很少用了，但在面试题中有可能会问到，我们来看一个经常出现的面试题：<strong>ArrayList 与 Vector 的区别是什么？</strong></p><p>**首先我们给出标准答案： **</p><p>**1、Vector 是线程安全的，ArrayList 不是线程安全的。 **</p><p><strong>2、ArrayList 在底层数组不够用时在原来的基础上扩展 0.5 倍，Vector 是扩展 1 倍。</strong></p><p>看上图 Vector 和 ArrayList 一样，都继承自 List，来看一下 Vector 的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The array buffer into which the components of the vector are</span><br><span class="hljs-comment">     * stored. The capacity of the vector is the length of this array buffer,</span><br><span class="hljs-comment">     * and is at least large enough to contain all the vector&#x27;s elements.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;Any array elements following the last element in the Vector are null.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> Object[] elementData;<br><br></code></pre></td></tr></table></figure><p>实现了 List 接口，底层和 ArrayList 一样，都是数组来实现的。分别看一下这两个类的 add 方法，首先来看 ArrayList 的 add 源码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Appends the specified element to the end of this list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e element to be appended to this list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">E e</span>) &#123;<br>        <span class="hljs-title function_">ensureCapacityInternal</span>(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!检查是否需要扩容</span><br>        elementData[size++] = e; <span class="hljs-comment">//给元素赋值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>再看 Vector 的 add 源码</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Appends the specified element to the end of this Vector.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e element to be appended to this Vector</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123; <span class="hljs-comment">//加了一个synchronized关键字</span><br>        modCount++;<br>        ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>); <span class="hljs-comment">//检查是否需要扩容</span><br>        elementData[elementCount++] = e; <span class="hljs-comment">//给元素赋值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>方法实现都一样，就是加了一个 synchronized 的关键字，remove 方法也是一样。</p><p><strong>只要是关键性的操作，方法前面都加了 synchronized 关键字，来保证线程的安全性</strong>。当执行 synchronized 修饰的方法前，系统会对该方法加一把锁，方法执行完成后释放锁，<strong>加锁和释放锁的这个过程，在系统中是有开销的，因此，</strong>在单线程的环境中，Vector 效率要差很多。（多线程环境不允许用 ArrayList，需要做处理）。</p><p><strong>和 ArrayList 和 Vector 一样，同样的类似关系的类还有 HashMap 和 HashTable，StringBuilder 和 StringBuffer，后者是前者线程安全版本的实现。</strong></p><h3 id="HashMap-原理及实现学习总结"><a href="#HashMap-原理及实现学习总结" class="headerlink" title="HashMap 原理及实现学习总结"></a>HashMap 原理及实现学习总结</h3><h4 id="一-HashMap-的工作原理"><a href="#一-HashMap-的工作原理" class="headerlink" title="一. HashMap 的工作原理"></a>一. HashMap 的工作原理</h4><p>HashMap 基于 hashing 原理，我们通过 put()和 get()方法储存和获取对象。当我们将键值对传递给 put()方法时，它调用键对象的 hashCode()方法来计算 hashcode，让后找到 bucket 位置来储存值对象。当获取对象时，通过键对象的 equals()方法找到正确的键值对，然后返回值对象。HashMap 使用 LinkedList 来解决碰撞问题，当发生碰撞了，对象将会储存在 LinkedList 的下一个节点中。 HashMap 在每个 LinkedList 节点中储存键值对对象。<br>当两个不同的键对象的 hashcode 相同时会发生什么？ 它们会储存在同一个 bucket 位置的 LinkedList 中。键对象的 equals()方法用来找到键值对。</p><h4 id="二-HashMap-的定义"><a href="#二-HashMap-的定义" class="headerlink" title="二.HashMap 的定义"></a>二.HashMap 的定义</h4><p>HashMap 实现了 Map 接口，继承 AbstractMap。其中 Map 接口定义了键映射到值的规则，而 AbstractMap 类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable<br></code></pre></td></tr></table></figure><h4 id="三-HashMap-的数据结构"><a href="#三-HashMap-的数据结构" class="headerlink" title="三.HashMap 的数据结构"></a>三.HashMap 的数据结构</h4><p>HashMap 的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap 中主要是通过 key 的 hashCode 来计算 hash 值的，只要 hashCode 相同，计算出来的 hash 值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的 hash 值是相同的，这就出现了所谓的 hash 冲突。学过数据结构的同学都知道，解决 hash 冲突的方法有很多，HashMap 底层是通过链表来解决 hash 冲突的。</p><p><img src="/images/java/hashmap.jpg" alt="hash"></p><p>紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的 key 映射到了数组的同一位置处，就将其放入单链表中。</p><h4 id="四-HashMap-的构造函数"><a href="#四-HashMap-的构造函数" class="headerlink" title="四.HashMap 的构造函数"></a>四.HashMap 的构造函数</h4><p>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响 HashMap 性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是 O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为 0.75，一般情况下我们是无需修改的。当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用 rehash 方法将容量翻倍。</p><h4 id="五-HashMap-的存储实现"><a href="#五-HashMap-的存储实现" class="headerlink" title="五.HashMap 的存储实现"></a>五.HashMap 的存储实现</h4><p>HashMap 中我们最长用的就是 put(K, V)和 get(K)。我们都知道，HashMap 的 K 值是唯一的，那如何保证唯一性呢？我们首先想到的是用 equals 比较，没错，这样可以实现，但随着内部元素的增多，put 和 get 的效率将越来越低，这里的时间复杂度是 O(n)，假如有 1000 个元素，put 时需要比较 1000 次。实际上，HashMap 很少会用到 equals 方法，因为其内通过一个哈希表管理所有元素，哈希是通过 hash 单词音译过来的，也可以称为散列表，哈希算法可以快速的存取元素，当我们调用 put 存值时，HashMap 首先会调用 K 的 hashCode 方法，获取哈希码，通过哈希码快速找到某个存放位置，这个位置可以被称之为 bucketIndex，通过上面所述 hashCode 的协定可以知道，如果 hashCode 不同，equals 一定为 false，如果 hashCode 相同，equals 不一定为 true。所以理论上，hashCode 可能存在冲突的情况，有个专业名词叫碰撞，当碰撞发生时，计算出的 bucketIndex 也是相同的，这时会取到 bucketIndex 位置已存储的元素，最终通过 equals 来比较，equals 方法就是哈希码碰撞时才会执行的方法，所以前面说 HashMap 很少会用到 equals。HashMap 通过 hashCode 和 equals 最终判断出 K 是否已存在，如果已存在，则使用新 V 值替换旧 V 值，并返回旧 V 值，如果不存在 ，则存放新的键值对到 bucketIndex 位置。整个 put 过程的流程图如下：</p><p><img src="/images/java/hashmap1.jpg"></p><p>相关源码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 在此映射中关联指定值与指定键。如果该映射以前包含了一个该键的映射关系，则旧值被替换</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>        <span class="hljs-comment">// 当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>        <span class="hljs-comment">// 使用hash函数预处理hashCode，计算key的hash值</span><br>        <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>());<span class="hljs-comment">//-------（1）</span><br>        <span class="hljs-comment">// 计算key hash 值在 table 数组中的位置</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<span class="hljs-comment">//------(2)</span><br>        <span class="hljs-comment">// 从i出开始迭代 e,找到 key 保存的位置</span><br>        <span class="hljs-keyword">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123;<br>            <span class="hljs-built_in">Object</span> k;<br>            <span class="hljs-comment">// 判断该条链上是否有hash值相同的(key相同)</span><br>            <span class="hljs-comment">// 若存在相同，则直接覆盖value，返回旧value</span><br>            <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>                <span class="hljs-comment">// 旧值 = 新值</span><br>                V oldValue = e.<span class="hljs-property">value</span>;<br>                <span class="hljs-comment">// 将要存储的value存进去</span><br>                e.<span class="hljs-property">value</span> = value;<br>                e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>                <span class="hljs-comment">// 返回旧的value</span><br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 修改次数增加1</span><br>        modCount++;<br>        <span class="hljs-comment">// 将key、value添加至i位置处</span><br>        <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过源码我们可以清晰看到 HashMap 保存数据的过程为：首先判断 key 是否为 null，若为 null，则直接调用 putForNullKey 方法。若不为空则先计算 key 的 hash 值，然后根据 hash 值搜索在 table 数组中的索引位置，如果 table 数组在该位置处有元素，则通过比较是否存在相同的 key，若存在则覆盖原来 key 的 value，否则将该元素保存在链头（最先保存的元素放在链尾）。若 table 在该处没有元素，则直接保存。这个过程看似比较简单，其实深有内幕。有如下几点：<br>1、 先看迭代处。此处迭代原因就是为了防止存在相同的 key 值，若发现两个 hash 值（key）相同时，HashMap 的处理方式是用新 value 替换旧 value，这里并没有处理 key，这就解释了 HashMap 中没有两个相同的 key。<br>2、 在看（1）、（2）处。这里是 HashMap 的精华所在。首先是 hash 方法，该方法为一个纯粹的数学计算，就是计算 h 的 hash 值。</p><p>HashMap 的底层数组长度总是 2 的 n 次方，在构造函数中存在：capacity &lt;&lt;&#x3D; 1;这样做总是能够保证 HashMap 的底层数组长度为 2 的 n 次方。当 length 为 2 的 n 次方时，h&amp;(length - 1)就相当于对 length 取模，而且速度比直接取模快得多，这是 HashMap 在速度上的一个优化。<br>这里再来复习 put 的流程：当我们想一个 HashMap 中添加一对 key-value 时，系统首先会计算 key 的 hash 值，然后根据 hash 值确认在 table 中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其 key 的 hash 值。如果两个 hash 值相等且 key 值相等(e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))),则用新的 Entry 的 value 覆盖原来节点的 value。如果两个 hash 值相等但 key 值不等 ，则将该节点插入该链表的链头。具体的实现过程见 addEntry 方法，如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 添加一个新的桶来保存该key和value</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEntry</span>(<span class="hljs-type">int</span> hash, K <span class="hljs-built_in">key</span>, V value, <span class="hljs-type">int</span> bucketIndex) &#123;<br>        <span class="hljs-comment">// 获取bucketIndex处的Entry</span><br>        Entry&lt;K, V&gt; e = table[bucketIndex];<br>        <span class="hljs-comment">// 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry</span><br>        table[bucketIndex] = <span class="hljs-keyword">new </span><span class="hljs-class title_">Entry</span>&lt;K, V&gt;(hash, <span class="hljs-built_in">key</span>, value, e);<br>        <span class="hljs-comment">// 若HashMap中元素的个数超过极限了，则容量扩大两倍</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>++ &gt;= threshold)<br>            <span class="hljs-comment">// 调整容量</span><br>            <span class="hljs-title function_">resize</span>(<span class="hljs-number">2</span> * table.<span class="hljs-property">length</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个方法中有两点需要注意：<br>一是链的产生：系统总是将新的 Entry 对象添加到 bucketIndex 处。如果 bucketIndex 处已经有了对象，那么新添加的 Entry 对象将指向原有的 Entry 对象，形成一条 Entry 链，但是若 bucketIndex 处没有 Entry 对象，也就是 e&#x3D;&#x3D;null,那么新添加的 Entry 对象指向 null，也就不会产生 Entry 链了。<br>二是扩容问题：随着 HashMap 中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响 HashMap 的速度，为了保证 HashMap 的效率，系统必须要在某个临界点进行扩容处理。该临界点在当 HashMap 中元素的数量等于 table 数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新 table 数组中的位置并进行复制处理。所以如果我们已经预知 HashMap 中元素的个数，那么预设元素的个数能够有效的提高 HashMap 的性能。</p><h4 id="六-和其他-Map-比较"><a href="#六-和其他-Map-比较" class="headerlink" title="六.和其他 Map 比较"></a>六.和其他 Map 比较</h4><h6 id="HashMap、ConcurrentHashMap、HashTable-的区别"><a href="#HashMap、ConcurrentHashMap、HashTable-的区别" class="headerlink" title="HashMap、ConcurrentHashMap、HashTable 的区别"></a>HashMap、ConcurrentHashMap、HashTable 的区别</h6><p>引入<code>ConcurrentHashMap</code>是为了在同步集合 HashTable 之间有更好的选择，<code>HashTable</code>与<code>HashMap</code>、<code>ConcurrentHashMap</code>主要的区别在于 HashMap 不是同步的、线程不安全的和不适合应用于多线程并发环境下，而<code>ConcurrentHashMap</code>是线程安全的集合容器，特别是在多线程和并发环境中，通常作为<code>Map</code>的主要实现。除了线程安全外，他们之间还有一些细微的不同，本文会介绍到。顺便说说，<code>HashMap</code>和<code>ConcurrentHashMap</code>还有<code>ConcurrentHashMap</code>和<code>Hashtable</code>两者之间的区别在 Java 面试中经常出现，特别是高级 Java 程序员。</p><h6 id="HashMap-与-ConcurrentHashMap-的区别"><a href="#HashMap-与-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 与 ConcurrentHashMap 的区别"></a>HashMap 与 ConcurrentHashMap 的区别</h6><p>在这部分，我们会看到更多关于<code>HashMap</code>和<code>ConcurrentHashMap</code>的细节和对比它们之间的参数比如线程安全、同步、性能和基本的使用。</p><ol><li><p>就像上面所说他们之间的第一个重要的区别就是<code>ConcurrentHashMap</code>是线程安全的和在并发环境下不需要加额外的同步。虽然它不像<code>Hashtable</code>那样需要同样的同步等级(全表锁)，但也有很多实际的用途。</p></li><li><p>你可以使用<code>Collections.synchronizedMap(HashMap)</code>来包装 HashMap 作为同步容器，这时它的作用几乎与<code>Hashtable</code>一样,当每次对<code>Map</code>做修改操作的时候都会锁住这个<code>Map</code>对象，而<code>ConcurrentHashMap</code>会基于并发的等级来划分整个 Map 来达到线程安全，它只会锁操作的那一段数据而不是整个<code>Map</code>都上锁。</p></li><li><p><code>ConcurrentHashMap</code>有很好的扩展性，在多线程环境下性能方面比做了同步的<code>HashMap</code>要好，但是在单线程环境下，<code>HashMap</code>会比<code>ConcurrentHashMap</code>好一点。</p></li></ol><h6 id="ConcurrentHashMap-vs-Hashtable-vs-Synchronized-Map"><a href="#ConcurrentHashMap-vs-Hashtable-vs-Synchronized-Map" class="headerlink" title="ConcurrentHashMap vs Hashtable vs Synchronized Map"></a>ConcurrentHashMap vs Hashtable vs Synchronized Map</h6><p>虽然三个集合类在多线程并发应用中都是线程安全的，但是他们有一个重大的差别，就是他们各自实现线程安全的方式。<code>Hashtable</code>是 jdk1 的一个遗弃的类，它把所有方法都加上<code>synchronized</code>关键字来实现线程安全。所有的方法都同步这样造成多个线程访问效率特别低。<code>Synchronized Map</code>与<code>HashTable</code>差别不大，也是在并发中作类似的操作，两者的唯一区别就是<code>Synchronized Map</code>没被遗弃，它可以通过使用<code>Collections.synchronizedMap()</code>来包装<code>Map</code>作为同步容器使用。</p><p>另一方面，<code>ConcurrentHashMap</code>的设计有点特别，表现在多个线程操作上。它不用做外的同步的情况下默认同时允许 16 个线程读和写这个 Map 容器。因为其内部的实现剥夺了锁，使它有很好的扩展性。不像<code>HashTable</code>和<code>Synchronized Map</code>，<code>ConcurrentHashMap</code>不需要锁整个 Map，相反它划分了多个段(segments)，要操作哪一段才上锁那段数据。</p><p>坦白说，集合类是一个最重要的 Java API，我觉得恰当的使用它们是一种艺术。依我个人经验，我会使用<code>ArrayList</code>这些容器来提高自己的 Java 程序的性能，而不会去用一些遗弃的容器比如<code>Vector</code>等等，在 Java 5 之前，Java 集合容器有一个很致命的缺陷就是缺乏可扩展性。<br>同步集合类比如<code>Hashtable</code>和<code>Vector</code>在多线程 Java 应用里面逐渐成为障碍物；在 jdk5 后出现一些很好的并发集合，对大容量、低延迟的电子交易系统有很大影响，是快速存取数据的支柱。</p><h3 id="正确理解-Thread-Local-的原理与适用场景"><a href="#正确理解-Thread-Local-的原理与适用场景" class="headerlink" title="正确理解 Thread Local 的原理与适用场景"></a>正确理解 Thread Local 的原理与适用场景</h3><h4 id="ThreadLocal-解决什么问题"><a href="#ThreadLocal-解决什么问题" class="headerlink" title="ThreadLocal 解决什么问题"></a>ThreadLocal 解决什么问题</h4><p>由于 ThreadLocal 支持范型，如 ThreadLocal&lt; StringBuilder &gt;，为表述方便，后文用 <strong>变量</strong> 代表 ThreadLocal 本身，而用 <strong>实例</strong> 代表具体类型（如 StringBuidler ）的实例。</p><h5 id="不恰当的理解"><a href="#不恰当的理解" class="headerlink" title="不恰当的理解"></a>不恰当的理解</h5><p>下面是常见的对于 ThreadLocal 的介绍</p><blockquote><p>ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路<br>ThreadLocal 的目的是为了解决多线程访问资源时的共享问题</p></blockquote><p>还有很多文章在对比 ThreadLocal 与 synchronize 的异同。既然是作比较，那应该是认为这两者解决相同或类似的问题。</p><p>上面的描述，问题在于，ThreadLocal 并不解决多线程 <strong>共享</strong> 变量的问题。既然变量不共享，那就更谈不上同步的问题。</p><h5 id="合理的理解"><a href="#合理的理解" class="headerlink" title="合理的理解"></a>合理的理解</h5><p>ThreadLocal 变量，它的基本原理是，同一个 ThreadLocal 所包含的对象（对 ThreadLocal&lt; String &gt;而言即为 String 类型变量），在不同的 Thread 中有不同的副本（实际是不同的实例，后文会详细阐述）。这里有几点需要注意</p><ul><li>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来</li><li>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题</li><li>既无共享，何来同步问题，又何来解决同步问题一说？</li></ul><p>那 ThreadLocal 到底解决了什么问题，又适用于什么样的场景？</p><blockquote><p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).<br>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p></blockquote><blockquote><p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p></blockquote><p>总的来说，<strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</strong>后文会通过实例详细阐述该观点。另外，该场景下，并非必须使用 ThreadLocal ，其它方式完全可以实现同样的效果，只是 ThreadLocal 使得实现更简洁。</p><h4 id="ThreadLocal-用法"><a href="#ThreadLocal-用法" class="headerlink" title="ThreadLocal 用法"></a>ThreadLocal 用法</h4><p>下面通过如下代码说明 ThreadLocal 的使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalDemo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">threads</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threads);<br>    <span class="hljs-type">InnerClass</span> <span class="hljs-variable">innerClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= threads; i++) &#123;<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>          innerClass.add(String.valueOf(j));<br>          innerClass.print();<br>        &#125;<br>        innerClass.set(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        countDownLatch.countDown();<br>      &#125;, <span class="hljs-string">&quot;thread - &quot;</span> + i).start();<br>    &#125;<br>    countDownLatch.await();<br><br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String newStr)</span> &#123;<br>      <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Counter.counter.get();<br>      Counter.counter.set(str.append(newStr));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>      System.out.printf(<span class="hljs-string">&quot;Thread name:%s , ThreadLocal hashcode:%s, Instance hashcode:%s, Value:%s\n&quot;</span>,<br>      Thread.currentThread().getName(),<br>      Counter.counter.hashCode(),<br>      Counter.counter.get().hashCode(),<br>      Counter.counter.get().toString());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String words)</span> &#123;<br>      Counter.counter.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(words));<br>      System.out.printf(<span class="hljs-string">&quot;Set, Thread name:%s , ThreadLocal hashcode:%s,  Instance hashcode:%s, Value:%s\n&quot;</span>,<br>      Thread.currentThread().getName(),<br>      Counter.counter.hashCode(),<br>      Counter.counter.get().hashCode(),<br>      Counter.counter.get().toString());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;StringBuilder&gt; counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;StringBuilder&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> StringBuilder <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>      &#125;<br>    &#125;;<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码执行结果如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">1</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">418873098</span>, Value:<span class="hljs-number">0</span><br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">3</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">1609588821</span>, Value:<span class="hljs-number">0</span><br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">2</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">1780437710</span>, Value:<span class="hljs-number">0</span><br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">3</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">1609588821</span>, Value:<span class="hljs-number">01</span><br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">1</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">418873098</span>, Value:<span class="hljs-number">01</span><br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">3</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">1609588821</span>, Value:<span class="hljs-number">012</span><br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">3</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">1609588821</span>, Value:<span class="hljs-number">0123</span><br><span class="hljs-attribute">Set</span>, Thread name:thread - <span class="hljs-number">3</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>,  Instance hashcode:<span class="hljs-number">1362597339</span>, Value:hello world<br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">2</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">1780437710</span>, Value:<span class="hljs-number">01</span><br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">1</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">418873098</span>, Value:<span class="hljs-number">012</span><br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">2</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">1780437710</span>, Value:<span class="hljs-number">012</span><br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">1</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">418873098</span>, Value:<span class="hljs-number">0123</span><br><span class="hljs-attribute">Thread</span> name:thread - <span class="hljs-number">2</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>, Instance hashcode:<span class="hljs-number">1780437710</span>, Value:<span class="hljs-number">0123</span><br><span class="hljs-attribute">Set</span>, Thread name:thread - <span class="hljs-number">1</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>,  Instance hashcode:<span class="hljs-number">482932940</span>, Value:hello world<br><span class="hljs-attribute">Set</span>, Thread name:thread - <span class="hljs-number">2</span> , ThreadLocal hashcode:<span class="hljs-number">372282300</span>,  Instance hashcode:<span class="hljs-number">1691922941</span>, Value:hello world<br></code></pre></td></tr></table></figure><p>从上面的输出可看出</p><ul><li>从第 1-3 行输出可见，每个线程通过 ThreadLocal 的 get() 方法拿到的是不同的 StringBuilder 实例</li><li>第 1-3 行输出表明，每个线程所访问到的是同一个 ThreadLocal 变量</li><li>从 7、12、13 行输出以及第 30 行代码可见，虽然从代码上都是对 Counter 类的静态 counter 字段进行 get() 得到 StringBuilder 实例并追加字符串，但是这并不会将所有线程追加的字符串都放进同一个 StringBuilder 中，而是每个线程将字符串追加进各自的 StringBuidler 实例内</li><li>对比第 1 行与第 15 行输出并结合第 38 行代码可知，使用 set(T t) 方法后，ThreadLocal 变量所指向的 StringBuilder 实例被替换</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github</title>
    <link href="/2020/04/28/git/github/"/>
    <url>/2020/04/28/git/github/</url>
    
    <content type="html"><![CDATA[<h2 id="github-Clone-加速"><a href="#github-Clone-加速" class="headerlink" title="github Clone 加速"></a>github Clone 加速</h2><blockquote><p>git config –global http.postBuffer 524288000<br>postBuffer(智能 HTTP 传输所使用的缓冲区)</p></blockquote><h3 id="修改-git-代理"><a href="#修改-git-代理" class="headerlink" title="修改 git 代理"></a>修改 git 代理</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">git config <span class="hljs-params">--global</span> http.proxy &#x27;http:<span class="hljs-string">//127.0.0.1</span><span class="hljs-function">:1080</span>&#x27;<br><br>git config <span class="hljs-params">--global</span> https.proxy &#x27;http:<span class="hljs-string">//127.0.0.1</span><span class="hljs-function">:1080</span>&#x27;<br><br><span class="hljs-comment"># 只对github.com代理</span><br>git config <span class="hljs-params">--global</span> http.https:<span class="hljs-string">//github.com.proxy</span> socks5:<span class="hljs-string">//127.0.0.1</span><span class="hljs-function">:1080</span><br><span class="hljs-comment"># 取消代理</span><br>git config <span class="hljs-params">--global</span> <span class="hljs-params">--unset</span> http.https:<span class="hljs-string">//github.com.proxy</span><br></code></pre></td></tr></table></figure><p>只修改 github 的代理,不影响其他仓库</p><h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> http<span class="hljs-selector-class">.proxy</span><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> https.proxy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Subtree</title>
    <link href="/2020/04/28/git/Git-Subtree/"/>
    <url>/2020/04/28/git/Git-Subtree/</url>
    
    <content type="html"><![CDATA[<h2 id="用-Git-Subtree-在多个-Git-项目间双向同步子项目，附简明使用手册"><a href="#用-Git-Subtree-在多个-Git-项目间双向同步子项目，附简明使用手册" class="headerlink" title="用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册"></a>用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册</h2><p>转自<a href="https://tech.youzan.com/git-subtree/">https://tech.youzan.com/git-subtree/</a></p><blockquote><p>什么时候需要 Subtree ？<br>1、当多个项目共用同一坨代码，而这坨代码跟着项目在快速更新的时候<br>2、把一部分代码迁移出去独立为一个新的 git 仓库，但又希望能够保留这部分代码的历史提交记录。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有赞微商城曾经是一个很大的前后端代码都包含在里面的 Git 项目，为了方便管理我们把前后端代码分离成 2 个 Git 仓库，进而再作分项目拆分成多个 Git 仓库。</p><p>于是，就需要有好的方式同步各个项目共用的 Css 库、JS 库、PHP 库（他们都是以独立的 Git 仓库的形式存在）。而且由于开发节奏极快，我们需要这些库是<strong>可以在不同项目间双向同步的而不是单向同步</strong>。<strong>而且，最好能做到被迁移的这部分代码在新的 git 仓库里保留原有的历史提交记录。</strong></p><p>举个栗子：A 项目需要在给某个子项目 W 里添加一个文件，最方便的方式自然是直接在 A 项目里改 W 子项目对应的目录里的代码，然后测试通过后，把这个更改提交到 W 子项目的 Git 仓库里。如果这时候还要先单独更新 W 子项目的代码然后提交到 Git 服务器，再在 A 项目里把 W 子项目的代码更新过来，显然是很麻烦的，更麻烦的是如果发现代码有 bug，还得再走一遍这个流程。</p><h3 id="有什么方案？"><a href="#有什么方案？" class="headerlink" title="有什么方案？"></a>有什么方案？</h3><ul><li><a href="http://git-scm.com/docs/git-submodule">Git Submodule</a>：这是 Git 官方以前的推荐方案</li><li><a href="https://medium.com/@porteneuve/mastering-git-Subtrees-943d29a798ec">Git Subtree</a>：从 <a href="http://lwn.net/Articles/235109/">Git 1.5.2</a> 开始，Git 新增并推荐使用这个功能来管理子项目</li><li><a href="https://www.npmjs.com/">npm</a>：node package manager，实际上不仅仅是 node 的包管理工具</li><li><a href="https://getcomposer.org/">composer</a>：暂且认为他是 php 版 npm、php 版 Maven 吧</li><li><a href="http://bower.io/">bower</a>：针对浏览器前端的包管理工具（Web sites are made of lots of things — frameworks, libraries, assets, utilities, and rainbows. Bower manages all these things for you.），这东西很好用，我们在大量使用。</li></ul><p>虽然 npm、composer、maven 等更侧重于包的依赖管理，以上几个方案都是能够做到在不同项目中同步同一块代码的，但没法双向同步，更适用于子项目代码比较稳定的情形。</p><p>Git Submodule 和 Git Subtree 都是官方支持的功能，不具有依赖管理的功能，但能满足我们的要求。Git Subtree 相对来说会<a href="http://somethingsinistral.net/blog/git-submodules-are-probably-not-the-answer/">更好一些</a> 。</p><h3 id="Git-Subtree-好在哪里"><a href="#Git-Subtree-好在哪里" class="headerlink" title="Git Subtree 好在哪里"></a>Git Subtree 好在哪里</h3><p>用一句话来描述 Git Subtree 的优势就是：</p><blockquote><p>经由 Git Subtree 来维护的子项目代码，对于父项目来说是透明的，所有的开发人员<strong>看到的就是一个普通的目录，原来怎么做现在依旧那么做</strong>，只需要维护这个 Subtree 的人在合适的时候去做同步代码的操作。</p></blockquote><p>它是怎么做到的呢？简单说下原理</p><h3 id="Git-Subtree-的原理"><a href="#Git-Subtree-的原理" class="headerlink" title="Git Subtree 的原理"></a>Git Subtree 的原理</h3><p>首先，你有两个伟大的项目——我们叫他 P1 项目、P2 项目，还有一个牛逼的要被多个项目共用的项目——我们叫他 S 项目。我们通过简要讲解使用 Subtree 来同步代码的过程来解释 Subtree 的原理</p><h4 id="1、初始化子项目-Subtree"><a href="#1、初始化子项目-Subtree" class="headerlink" title="1、初始化子项目 Subtree"></a>1、初始化子项目 Subtree</h4><p>通过</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd P1项目的路径<br>git subtree <span class="hljs-built_in">add</span> <span class="hljs-attribute">--prefix</span>=用来放S项目的相对路径 S项目git地址 xxx分支<br><br>12<br></code></pre></td></tr></table></figure><p>这样的命令，把 S 项目（我们姑且叫他 S 项目）的代码下载到–prefix 所指定的目录——我们姑且叫他 S 目录把，并在 P1 项目里自动产生一个 commit（就是把 S 目录的内容提交到 P1 项目里）。</p><p><em>对于 P2 项目也做同样的操作</em></p><h4 id="2、像往常一样更新代码"><a href="#2、像往常一样更新代码" class="headerlink" title="2、像往常一样更新代码"></a>2、像往常一样更新代码</h4><p>大家在 P1 项目里各种提交 commit，其中有些 commit 会涉及到 S 目录的更改，正如前面提到的，这是没任何关系的，大家也不会感受到有任何不一样。</p><h4 id="3、提交更改到子项目的-Git-服务器"><a href="#3、提交更改到子项目的-Git-服务器" class="headerlink" title="3、提交更改到子项目的 Git 服务器"></a>3、提交更改到子项目的 Git 服务器</h4><p><strong>关键的地方来了：</strong> 当维护这个 S 项目 Subtree 的人希望把最近这段时间对 S 目录的更改提交到 S 项目的 Git 服务器上时，他执行一段类似于这样的命令：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">cd</span> <span class="hljs-built_in">P1</span>项目的路径<br><span class="hljs-symbol">git</span> subtree <span class="hljs-keyword">push</span> --prefix<span class="hljs-symbol">=S</span>项目的路径 S项目git地址 xxx分支<br><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>Git 会遍历所有的 commit，从中找出针对 S 目录的更改，然后把这些更改记录提交到 S 项目的 Git 服务器上</p><h4 id="4、更新子项目新的代码到父项目"><a href="#4、更新子项目新的代码到父项目" class="headerlink" title="4、更新子项目新的代码到父项目"></a>4、更新子项目新的代码到父项目</h4><p>OK，现在 S 项目有大量的新代码了，P2 项目也想使用这些新代码，维护 P2 这个 Subtree 的人只要执行：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">subtree </span>pull --<span class="hljs-keyword">prefix=S项目的路径 </span>S项目git地址 xxx分支<br><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这样就可以将 P2 项目里 S 项目目录里的内容更新为 S 项目 xxx 分支的最新代码了。</p><h3 id="我们总结的-Git-Subtree-简明使用手册"><a href="#我们总结的-Git-Subtree-简明使用手册" class="headerlink" title="我们总结的 Git Subtree 简明使用手册"></a>我们总结的 Git Subtree 简明使用手册</h3><p>假设，你要在各个项目里的<em>components&#x2F;zenjs</em>这个目录对 <em><a href="http://github.com/youzan/zenjs.git">http://github.com/youzan/zenjs.git</a></em> 这个项目做 Subtree</p><p>1.首先必须确保各个项目已经添加 zenjs 这个 remote（关于 remote 是什么可以看<a href="http://git-scm.com/docs/git-remote">这里</a>）:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> zenjs http:<span class="hljs-comment">//github.com/youzan/zenjs.git</span><br><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>2.将 zenjs 添加到各个项目里</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git subtree <span class="hljs-built_in">add</span> <span class="hljs-attribute">--prefix</span>=components/zenjs zenjs master<br><br>1<br></code></pre></td></tr></table></figure><p>3.各项目更新 zenjs 代码的方法:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git subtree pull --<span class="hljs-attr">prefix=</span>components/zenjs zenjs <span class="hljs-keyword">master</span><br><br><span class="hljs-title">1</span><br></code></pre></td></tr></table></figure><p>4.各项目提交 zenjs 代码的方法:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git subtree <span class="hljs-built_in">push</span> --<span class="hljs-built_in">prefix</span>=<span class="hljs-built_in">components</span>/zenjs zenjs hotfix/zenjs_xxxx<br><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这会在远程的 zenjs 的仓库里生成一个叫 hotfix&#x2F;zenjs_xxxx 的的分支，包含了你过去对 components&#x2F;zenjs 所有的更改记录</p><ol><li>把 hotfix&#x2F;zenjs_xxx 分支更新并合并到 master 并提交</li></ol><p>这样其他工程就可以更新到你提交的代码了。</p><blockquote><p>有人可能会问，只用 master 分支，不管版本，太有风险了。</p><p>对的，正如我们前面说到的那样，subtree 的方案适用的场景是：各个项目共用一个库，而这个库正在快速迭代更新的过程中。如果追求稳定，只需要给库拉出一个如 v0.1.0 这样的版本号命名的稳定分支，subtree 只用这个分支即可。</p><p>我们现在使用的方式就是：A 项目经常会对 zenjs 做更新，所以 A 项目用 subtree 来双向同步；B 项目只是使用，所以用 bower 用来按版本来更新代码。</p></blockquote><p><strong>高阶功能:</strong> 重新 split 出一个新起点（这样，每次提交 subtree 的时候就不会从头遍历一遍了）</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git subtree <span class="hljs-built_in">split</span> --rejoin --<span class="hljs-built_in">prefix</span>=<span class="hljs-built_in">components</span>/zenjs --branch new_zenjs<br>git <span class="hljs-built_in">push</span> zenjs new_zenjs:master<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Config</title>
    <link href="/2020/04/20/Linux-Config/"/>
    <url>/2020/04/20/Linux-Config/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-初始化的一些简单配置"><a href="#Ubuntu-初始化的一些简单配置" class="headerlink" title="Ubuntu 初始化的一些简单配置"></a>Ubuntu 初始化的一些简单配置</h1><h2 id="ssh-配置"><a href="#ssh-配置" class="headerlink" title="ssh 配置"></a>ssh 配置</h2><ul><li><p>安装 ssh</p><blockquote><p>apt-get install opnessh-server</p></blockquote></li><li><p>如果出现错误 Connection closed by ip</p><blockquote><p>sudo dpkg-reconfigure openssh-server</p></blockquote><p>然后再重新修改一些端口等配置</p></li></ul><h2 id="更换国内源-阿里云源感觉不是很稳定-一般用中科大的"><a href="#更换国内源-阿里云源感觉不是很稳定-一般用中科大的" class="headerlink" title="更换国内源,阿里云源感觉不是很稳定,一般用中科大的"></a>更换国内源,阿里云源感觉不是很稳定,一般用中科大的</h2><blockquote><p>vim &#x2F;etc&#x2F;apt&#x2F;sources.list<br>删除原有的</p></blockquote><p>替换为</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 1c">deb https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br>deb<span class="hljs-punctuation">-</span>src https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br>deb https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br>deb<span class="hljs-punctuation">-</span>src https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br>deb https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br>deb<span class="hljs-punctuation">-</span>src https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br>deb https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br>deb<span class="hljs-punctuation">-</span>src https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br>deb https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br>deb<span class="hljs-punctuation">-</span>src https<span class="hljs-punctuation">:</span><span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></code></pre></td></tr></table></figure><blockquote><p>sudo apt-get update<br>sudo apt-get upgrade</p></blockquote><h2 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h2><blockquote><p>sudo apt-get install zsh</p></blockquote><blockquote><p>chsh -s &#x2F;bin&#x2F;zsh</p></blockquote><blockquote><p>sudo apt-get install git</p></blockquote><h4 id="配置-git"><a href="#配置-git" class="headerlink" title="配置 git"></a>配置 git</h4><ul><li>配置个人信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="hljs-string">&quot;email@example.com&quot;</span></span><br></code></pre></td></tr></table></figure><ul><li>生成 SSH</li></ul><blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#x6f;&#x75;&#x72;&#101;&#x6d;&#x61;&#105;&#x6c;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;">&#x79;&#x6f;&#x75;&#x72;&#101;&#x6d;&#x61;&#105;&#x6c;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;</a>“</p></blockquote><blockquote><p>sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh</a>)”</p></blockquote><blockquote><p>更换主题 agnoster</p></blockquote><h2 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h2><ul><li>安装最新 nodejs 方法</li></ul><blockquote><p>curl -sL <a href="https://deb.nodesource.com/setup_12.x">https://deb.nodesource.com/setup_12.x</a> | sudo -E bash -<br>sudo apt-get install -y nodejs</p></blockquote><h3 id="替换-npm-源"><a href="#替换-npm-源" class="headerlink" title="替换 npm 源"></a>替换 npm 源</h3><p>1.临时使用</p><blockquote><p>npm –registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> install express</p></blockquote><p>2.持久使用</p><blockquote><p>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>&#x2F;&#x2F; 配置后可通过下面方式来验证是否成功<br>npm config get registry<br>&#x2F;&#x2F; 或<br>npm info express</p></blockquote><p>3.通过 cnpm 使用</p><blockquote><p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>&#x2F;&#x2F; 使用<br>cnpm install expresstall express</p></blockquote><h2 id="Centos-一些配置"><a href="#Centos-一些配置" class="headerlink" title="Centos 一些配置"></a>Centos 一些配置</h2><h3 id="ifconfig-command-not-found"><a href="#ifconfig-command-not-found" class="headerlink" title="ifconfig command not found"></a>ifconfig command not found</h3><blockquote><p>yum install net-tools</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
